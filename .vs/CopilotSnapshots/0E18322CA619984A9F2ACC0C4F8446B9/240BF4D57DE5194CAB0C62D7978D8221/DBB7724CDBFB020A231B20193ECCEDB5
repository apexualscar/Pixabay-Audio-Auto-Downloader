// Content script for Pixabay Sound Effects Downloader - Focused Audio Extraction
console.log('Pixabay Sound Effects Downloader content script loaded');

let isContentScriptActive = false;
let scrapingInProgress = false;

// Store target info for consistent folder naming
let targetInfo = {
    targetName: 'unknown',
    targetID: 'unknown',
    extracted: false
};

// Initialize content script
function initializeContentScript() {
    if (isContentScriptActive) return;
    
    console.log('Initializing Pixabay sound effects content script...');
    isContentScriptActive = true;
    
    // Check if we're on a Pixabay page
    if (window.location.hostname.includes('pixabay.com')) {
        console.log('Pixabay page detected');
        
        // Extract and store target info immediately
        extractAndStoreTargetInfo();
        
        // Add visual indicators that scraping is available
        addScrapingIndicators();
        
        // Listen for messages from background script
        chrome.runtime.onMessage.addListener(handleBackgroundMessage);
    }
}

function extractAndStoreTargetInfo() {
    try {
        console.log('Extracting target information for folder naming...');
        
        const url = window.location.href;
        const pathname = window.location.pathname;
        
        // Extract username and ID from URL
        const userMatch = pathname.match(/\/users\/([^\/\?]+)/);
        if (userMatch) {
            targetInfo.targetName = decodeURIComponent(userMatch[1]);
            targetInfo.targetID = decodeURIComponent(userMatch[1]); // Use username as ID initially
            
            console.log(`Extracted target info from URL - Name: ${targetInfo.targetName}, ID: ${targetInfo.targetID}`);
        }
        
        // Try to extract numeric user ID from page elements for better targeting
        const userIdSelectors = [
            '[data-user-id]',
            '[data-id]',
            '.user-id',
            '#user-id',
            '[class*="user-id"]'
        ];
        
        for (const selector of userIdSelectors) {
            const element = document.querySelector(selector);
            if (element) {
                const id = element.getAttribute('data-user-id') || 
                          element.getAttribute('data-id') || 
                          element.textContent?.trim();
                if (id && /^\d+$/.test(id)) {
                    targetInfo.targetID = id;
                    console.log(`Found numeric user ID: ${targetInfo.targetID}`);
                    break;
                }
            }
        }
        
        // Also try to get display name from page elements
        const nameSelectors = [
            '.h1--bZ6EI.L--opXRs', // Primary selector for user name
            '.h1--bZ6EI',          // Fallback without second class
            'h1.h1--bZ6EI',        // With h1 tag
            '.user-name',
            '.profile-name',
            'h1',
            'h2'
        ];
        
        for (const selector of nameSelectors) {
            const nameEl = document.querySelector(selector);
            if (nameEl && nameEl.textContent?.trim()) {
                const displayName = nameEl.textContent.trim();
                // Use display name if it's different and more descriptive
                if (displayName !== targetInfo.targetName && displayName.length > 2) {
                    targetInfo.targetName = displayName;
                    console.log(`Updated target name from page: ${targetInfo.targetName}`);
                }
                break;
            }
        }
        
        targetInfo.extracted = true;
        console.log('Final target info:', targetInfo);
        
    } catch (error) {
        console.error('Error extracting target info:', error);
        targetInfo = {
            targetName: 'unknown',
            targetID: 'unknown',
            extracted: true
        };
    }
}

function addScrapingIndicators() {
    // Add a subtle indicator that the scraper is active
    const indicator = document.createElement('div');
    indicator.id = 'pixabay-sound-scraper-indicator';
    indicator.innerHTML = `
        <div style="
            position: fixed;
            top: 10px;
            right: 10px;
            background: #4bc24b;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
            PeX Audio Scraper Ready (${targetInfo.targetName || 'Unknown'})
        </div>
    `;
    
    document.body.appendChild(indicator);
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
        const el = document.getElementById('pixabay-sound-scraper-indicator');
        if (el) {
            el.style.opacity = '0';
            el.style.transition = 'opacity 0.5s ease';
            setTimeout(() => el.remove(), 500);
        }
    }, 3000);
}

function handleBackgroundMessage(message, sender, sendResponse) {
    console.log('Content script received message:', message);
    
    switch (message.action) {
        case 'SCAN_SOUND_EFFECTS':
            scanSoundEffectsFromCurrentPage();
            break;
    }
}

async function scanSoundEffectsFromCurrentPage() {
    if (scrapingInProgress) {
        console.log('Scanning already in progress');
        return;
    }
    
    scrapingInProgress = true;
    
    try {
        console.log('Starting to scan sound effects from current page...');
        
        // Ensure target info is extracted
        if (!targetInfo.extracted) {
            extractAndStoreTargetInfo();
        }
        
        // Show scanning indicator
        showScrapingProgress('Scanning for sound effects...');
        
        // Wait for page to load completely
        await waitForPageLoad();
        
        // Scroll to load all content
        await scrollToLoadAll();
        
        // Extract sound effects using optimized selectors
        const soundEffects = await extractSoundEffectsWithProgress();
        
        console.log(`Successfully extracted ${soundEffects.length} sound effects`);
        
        // Send results back to background script with target info
        chrome.runtime.sendMessage({
            action: 'SOUND_EFFECTS_EXTRACTED',
            items: soundEffects,
            targetInfo: targetInfo // Include target info for folder naming
        });
        
        hideScrapingProgress();
        
    } catch (error) {
        console.error('Error scanning sound effects:', error);
        hideScrapingProgress();
        chrome.runtime.sendMessage({
            action: 'SCANNING_ERROR',
            error: error.message
        });
    } finally {
        scrapingInProgress = false;
    }
}

function waitForPageLoad() {
    return new Promise((resolve) => {
        if (document.readyState === 'complete') {
            setTimeout(resolve, 2000); // Extra delay for dynamic content
        } else {
            window.addEventListener('load', () => {
                setTimeout(resolve, 2000);
            });
        }
    });
}

async function scrollToLoadAll() {
    console.log('Scrolling to load all sound effects...');
    
    return new Promise((resolve) => {
        let scrollCount = 0;
        let lastItemCount = 0;
        let stableCount = 0;
        const maxScrolls = 50; // Reduced since we're looking for specific elements
        
        function scrollStep() {
            // Count current sound effect items using optimized selector
            const currentItemCount = countSoundEffectsOnCurrentPage();
            
            // Check if new items loaded
            if (currentItemCount === lastItemCount) {
                stableCount++;
            } else {
                stableCount = 0;
                lastItemCount = currentItemCount;
                console.log(`Found ${currentItemCount} sound effects after scroll ${scrollCount}`);
                
                // Update progress
                showScrapingProgress(`Loading sound effects... Found ${currentItemCount} items`);
            }
            
            // Stop if no new items for 3 consecutive scrolls or max scrolls reached
            if (stableCount >= 3 || scrollCount >= maxScrolls) {
                console.log(`Scrolling complete. Final count: ${currentItemCount} sound effects`);
                window.scrollTo(0, 0); // Scroll back to top
                setTimeout(resolve, 2000);
                return;
            }
            
            // Scroll down
            window.scrollBy(0, 1000);
            scrollCount++;
            
            setTimeout(scrollStep, 1000); // Wait between scrolls
        }
        
        scrollStep();
    });
}

function countSoundEffectsOnCurrentPage() {
    // OPTIMIZED: Only scan elements with class container--qiTbg
    const optimizedContainers = document.querySelectorAll('.container--qiTbg');
    console.log(`Found ${optimizedContainers.length} optimized containers with class "container--qiTbg"`);
    
    // Fallback to previous selectors if optimized selector finds nothing
    if (optimizedContainers.length === 0) {
        const audioContainers = document.querySelectorAll('.overlayContainer--0ZpHP.lazyImg--u6+yh');
        const audioRows = document.querySelectorAll('.audioRow--nAm4Z');
        console.log(`Fallback: Found ${audioContainers.length} overlay containers and ${audioRows.length} audio rows`);
        return Math.max(audioContainers.length, audioRows.length);
    }
    
    return optimizedContainers.length;
}

async function extractSoundEffectsWithProgress() {
    console.log('Extracting sound effects using optimized selectors...');
    showScrapingProgress('Analyzing sound effects...');
    
    const soundEffects = [];
    
    // OPTIMIZED: First try the optimized selector for container--qiTbg
    const optimizedContainers = document.querySelectorAll('.container--qiTbg');
    console.log(`Found ${optimizedContainers.length} optimized containers with class "container--qiTbg"`);
    
    if (optimizedContainers.length > 0) {
        console.log('Using optimized container--qiTbg selector for extraction');
        
        for (let i = 0; i < optimizedContainers.length; i++) {
            const container = optimizedContainers[i];
            
            try {
                const soundEffect = await extractSoundEffectFromOptimizedContainer(container, i);
                if (soundEffect) {
                    soundEffects.push(soundEffect);
                    
                    // Update progress every 10 items
                    if (soundEffects.length % 10 === 0) {
                        showScrapingProgress(`Extracted ${soundEffects.length} sound effects...`);
                    }
                }
            } catch (error) {
                console.error(`Error processing optimized container ${i}:`, error);
            }
        }
    }
    
    // Fallback: Use previous selectors if optimized didn't find anything
    if (soundEffects.length === 0) {
        console.log('No sound effects found with optimized selector, using fallback selectors...');
        
        // Use the specific selectors you mentioned for sound effect items
        const overlayContainers = document.querySelectorAll('.overlayContainer--0ZpHP.lazyImg--u6+yh');
        console.log(`Found ${overlayContainers.length} overlay containers with classes "overlayContainer--0ZpHP lazyImg--u6+yh"`);
        
        // Also try the original audioRow selector as fallback
        const audioRows = document.querySelectorAll('.audioRow--nAm4Z');
        console.log(`Found ${audioRows.length} audio rows with class "audioRow--nAm4Z"`);
        
        // Process overlay containers first (your new selector)
        if (overlayContainers.length > 0) {
            for (let i = 0; i < overlayContainers.length; i++) {
                const container = overlayContainers[i];
                
                try {
                    const soundEffect = await extractSoundEffectFromOverlayContainer(container, i);
                    if (soundEffect) {
                        soundEffects.push(soundEffect);
                        
                        // Update progress every 10 items
                        if (soundEffects.length % 10 === 0) {
                            showScrapingProgress(`Extracted ${soundEffects.length} sound effects...`);
                        }
                    }
                } catch (error) {
                    console.error(`Error processing overlay container ${i}:`, error);
                }
            }
        }
        
        // If no overlay containers found, try audioRows as fallback
        if (soundEffects.length === 0 && audioRows.length > 0) {
            for (let i = 0; i < audioRows.length; i++) {
                const audioRow = audioRows[i];
                
                try {
                    const soundEffect = await extractSoundEffectFromRow(audioRow, i);
                    if (soundEffect) {
                        soundEffects.push(soundEffect);
                        
                        // Update progress every 10 items
                        if (soundEffects.length % 10 === 0) {
                            showScrapingProgress(`Extracted ${soundEffects.length} sound effects...`);
                        }
                    }
                } catch (error) {
                    console.error(`Error processing audio row ${i}:`, error);
                }
            }
        }
    }
    
    console.log(`Successfully extracted ${soundEffects.length} sound effects`);
    return soundEffects;
}

// NEW: Optimized extraction function for container--qiTbg elements
async function extractSoundEffectFromOptimizedContainer(container, index) {
    try {
        // Look for links within the optimized container
        const linkElement = container.querySelector('a');
        let itemUrl = linkElement ? linkElement.href : '';
        let itemId = `sound_${index}`;
        
        // Extract ID from URL if available
        if (itemUrl) {
            const idMatch = itemUrl.match(/\/(\d+)/);
            if (idMatch) {
                itemId = idMatch[1];
            }
        }
        
        // Look for image within the container
        const imgElement = container.querySelector('img');
        let previewUrl = '';
        let title = '';
        
        if (imgElement) {
            previewUrl = imgElement.src || imgElement.getAttribute('data-src') || '';
            title = imgElement.alt || imgElement.title || '';
        }
        
        // Try to find title from nearby elements or link text
        if (!title && linkElement) {
            title = linkElement.getAttribute('title') || 
                   linkElement.textContent?.trim() || '';
        }
        
        // Look for any text content within the container
        if (!title) {
            const textElements = container.querySelectorAll('span, div, p');
            for (const textEl of textElements) {
                const text = textEl.textContent?.trim();
                if (text && text.length > 2 && text.length < 100) {
                    title = text;
                    break;
                }
            }
        }
        
        // Generate fallback title if none found
        if (!title) {
            title = `Sound Effect ${index + 1}`;
        }
        
        // Try to extract the actual audio file URL
        let audioFileUrl = '';
        
        // Look for direct audio file links or preview URLs
        const audioSelectors = [
            'audio source[src]',
            'audio[src]',
            '[data-audio-url]',
            '[data-preview-url]',
            'source[type*="audio"]'
        ];
        
        for (const selector of audioSelectors) {
            const audioEl = container.querySelector(selector);
            if (audioEl) {
                audioFileUrl = audioEl.src || 
                              audioEl.getAttribute('data-audio-url') || 
                              audioEl.getAttribute('data-preview-url') || '';
                if (audioFileUrl) {
                    console.log(`Found direct audio URL: ${audioFileUrl}`);
                    break;
                }
            }
        }
        
        // If we have a page URL but no direct audio URL, try to extract from the page
        if (!audioFileUrl && itemUrl && itemUrl.includes('pixabay.com')) {
            try {
                audioFileUrl = await extractAudioUrlFromPage(itemUrl);
            } catch (error) {
                console.log(`Could not extract audio URL from page ${itemUrl}:`, error.message);
            }
        }
        
        // If still no audio URL, try to construct one based on patterns
        if (!audioFileUrl && itemId && itemId !== `sound_${index}`) {
            // Try common Pixabay audio URL patterns
            const possibleUrls = [
                `https://cdn.pixabay.com/audio/${itemId.slice(-2)}/${itemId}.mp3`,
                `https://cdn.pixabay.com/download/audio/${itemId}.mp3`,
                `https://pixabay.com/api/download/audio/${itemId}/?preview=1`
            ];
            
            for (const url of possibleUrls) {
                try {
                    const response = await fetch(url, { method: 'HEAD' });
                    if (response.ok && response.headers.get('content-type')?.includes('audio')) {
                        audioFileUrl = url;
                        console.log(`Found constructed audio URL: ${audioFileUrl}`);
                        break;
                    }
                } catch (error) {
                    // Continue trying other URLs
                }
            }
        }
        
        console.log(`Extracted from optimized container:`, {
            id: itemId,
            title: title,
            downloadUrl: audioFileUrl || itemUrl,
            previewUrl: previewUrl,
            pageUrl: itemUrl
        });
        
        return {
            id: itemId,
            title: title,
            downloadUrl: audioFileUrl || itemUrl,
            previewUrl: previewUrl,
            pageUrl: itemUrl,
            category: 'sound-effects',
            element: container
        };
        
    } catch (error) {
        console.error(`Error extracting from optimized container ${index}:`, error);
        return null;
    }
}

async function extractSoundEffectFromOverlayContainer(container, index) {
    try {
        // Look for links within the overlay container
        const linkElement = container.querySelector('a');
        let itemUrl = linkElement ? linkElement.href : '';
        let itemId = `sound_${index}`;
        
        // Extract ID from URL if available
        if (itemUrl) {
            const idMatch = itemUrl.match(/\/(\d+)/);
            if (idMatch) {
                itemId = idMatch[1];
            }
        }
        
        // Look for image within the container
        const imgElement = container.querySelector('img');
        let previewUrl = '';
        let title = '';
        
        if (imgElement) {
            previewUrl = imgElement.src || imgElement.getAttribute('data-src') || '';
            title = imgElement.alt || imgElement.title || '';
        }
        
        // Try to find title from nearby elements or link text
        if (!title && linkElement) {
            title = linkElement.getAttribute('title') || 
                   linkElement.textContent?.trim() || '';
        }
        
        // Look for any text content within the container
        if (!title) {
            const textElements = container.querySelectorAll('span, div, p');
            for (const textEl of textElements) {
                const text = textEl.textContent?.trim();
                if (text && text.length > 2 && text.length < 100) {
                    title = text;
                    break;
                }
            }
        }
        
        // Generate fallback title if none found
        if (!title) {
            title = `Sound Effect ${index + 1}`;
        }
        
        // Try to extract the actual audio file URL
        let audioFileUrl = '';
        
        // Look for direct audio file links or preview URLs
        const audioSelectors = [
            'audio source[src]',
            'audio[src]',
            '[data-audio-url]',
            '[data-preview-url]',
            'source[type*="audio"]'
        ];
        
        for (const selector of audioSelectors) {
            const audioEl = container.querySelector(selector);
            if (audioEl) {
                audioFileUrl = audioEl.src || 
                              audioEl.getAttribute('data-audio-url') || 
                              audioEl.getAttribute('data-preview-url') || '';
                if (audioFileUrl) {
                    console.log(`Found direct audio URL: ${audioFileUrl}`);
                    break;
                }
            }
        }
        
        // If we have a page URL but no direct audio URL, try to extract from the page
        if (!audioFileUrl && itemUrl && itemUrl.includes('pixabay.com')) {
            try {
                audioFileUrl = await extractAudioUrlFromPage(itemUrl);
            } catch (error) {
                console.log(`Could not extract audio URL from page ${itemUrl}:`, error.message);
            }
        }
        
        // If still no audio URL, try to construct one based on patterns
        if (!audioFileUrl && itemId && itemId !== `sound_${index}`) {
            // Try common Pixabay audio URL patterns
            const possibleUrls = [
                `https://cdn.pixabay.com/audio/${itemId.slice(-2)}/${itemId}.mp3`,
                `https://cdn.pixabay.com/download/audio/${itemId}.mp3`,
                `https://pixabay.com/api/download/audio/${itemId}/?preview=1`
            ];
            
            for (const url of possibleUrls) {
                try {
                    const response = await fetch(url, { method: 'HEAD' });
                    if (response.ok && response.headers.get('content-type')?.includes('audio')) {
                        audioFileUrl = url;
                        console.log(`Found constructed audio URL: ${audioFileUrl}`);
                        break;
                    }
                } catch (error) {
                    // Continue trying other URLs
                }
            }
        }
        
        console.log(`Extracted from overlay container:`, {
            id: itemId,
            title: title,
            downloadUrl: audioFileUrl || itemUrl,
            previewUrl: previewUrl,
            pageUrl: itemUrl
        });
        
        return {
            id: itemId,
            title: title,
            downloadUrl: audioFileUrl || itemUrl,
            previewUrl: previewUrl,
            pageUrl: itemUrl,
            category: 'sound-effects',
            element: container
        };
        
    } catch (error) {
        console.error(`Error extracting from overlay container ${index}:`, error);
        return null;
    }
}

async function extractSoundEffectFromRow(audioRow, index) {
    try {
        // Find the title using the specific selector you mentioned
        const nameAndTitleEl = audioRow.querySelector('.nameAndTitle--KcBAZ');
        let title = '';
        
        if (nameAndTitleEl) {
            title = nameAndTitleEl.textContent?.trim() || '';
            console.log(`Found title using nameAndTitle selector: "${title}"`);
        }
        
        // If no title found with specific selector, try alternatives
        if (!title) {
            const titleSelectors = [
                '.title',
                '.name',
                '.track-name',
                '.audio-title',
                'h3',
                'h4',
                '[class*="title"]',
                '[class*="name"]'
            ];
            
            for (const selector of titleSelectors) {
                const titleEl = audioRow.querySelector(selector);
                if (titleEl && titleEl.textContent?.trim()) {
                    title = titleEl.textContent.trim();
                    console.log(`Found title using fallback selector "${selector}": "${title}"`);
                    break;
                }
            }
        }
        
        // If still no title, generate one
        if (!title) {
            title = `Sound Effect ${index + 1}`;
        }
        
        // Try to find download link or audio source
        let pageUrl = '';
        let audioFileUrl = '';
        let itemId = '';
        
        // Look for links to individual sound pages
        const linkSelectors = [
            'a[href*="/sound-effects/"]',
            'a[href*="/music/"]',
            'a[href*="/audio/"]',
            'a[href*="pixabay.com"]'
        ];
        
        for (const selector of linkSelectors) {
            const link = audioRow.querySelector(selector);
            if (link && link.href) {
                pageUrl = link.href;
                
                // Extract ID from URL
                const idMatch = pageUrl.match(/\/(\d+)/);
                if (idMatch) {
                    itemId = idMatch[1];
                }
                break;
            }
        }
        
        // Look for direct audio elements or download links
        const audioSelectors = [
            'audio source[src]',
            'audio[src]',
            'a[href*=".mp3"]',
            'a[href*=".wav"]',
            'a[href*=".ogg"]',
            '[data-src*=".mp3"]',
            '[data-src*=".wav"]',
            '[data-audio-url]'
        ];
        
        for (const selector of audioSelectors) {
            const audioEl = audioRow.querySelector(selector);
            if (audioEl) {
                audioFileUrl = audioEl.src || 
                              audioEl.getAttribute('data-src') || 
                              audioEl.getAttribute('data-audio-url') || 
                              audioEl.href || '';
                if (audioFileUrl) {
                    console.log(`Found direct audio URL in row: ${audioFileUrl}`);
                    break;
                }
            }
        }
        
        // If we have page URL but no direct audio URL, try to extract it
        if (!audioFileUrl && pageUrl) {
            try {
                audioFileUrl = await extractAudioUrlFromPage(pageUrl);
            } catch (error) {
                console.log(`Could not extract audio URL from page ${pageUrl}:`, error.message);
            }
        }
        
        // Generate fallback ID if none found
        if (!itemId) {
            itemId = `sound_${index}`;
        }
        
        // Look for preview image
        let previewUrl = '';
        const imgEl = audioRow.querySelector('img');
        if (imgEl) {
            previewUrl = imgEl.src || imgEl.getAttribute('data-src') || '';
        }
        
        console.log(`Extracted sound effect:`, {
            id: itemId,
            title: title,
            downloadUrl: audioFileUrl || pageUrl,
            previewUrl: previewUrl,
            pageUrl: pageUrl
        });
        
        return {
            id: itemId,
            title: title,
            downloadUrl: audioFileUrl || pageUrl,
            previewUrl: previewUrl,
            pageUrl: pageUrl,
            category: 'sound-effects',
            element: audioRow
        };
        
    } catch (error) {
        console.error(`Error extracting sound effect from row ${index}:`, error);
        return null;
    }
}

// Function to extract actual audio file URL from a Pixabay sound effect page
async function extractAudioUrlFromPage(pageUrl) {
    try {
        console.log(`Attempting to extract audio URL from: ${pageUrl}`);
        
        // Fetch the page content
        const response = await fetch(pageUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const html = await response.text();
        
        // Look for common patterns in Pixabay's HTML that contain audio URLs
        const audioUrlPatterns = [
            /"preview":\s*"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"audioURL":\s*"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"download":\s*"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /data-audio-url="([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /src="([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /https:\/\/cdn\.pixabay\.com\/audio\/[^"']*\.(?:mp3|wav|ogg)/gi,
            /https:\/\/pixabay\.com\/[^"']*\.(?:mp3|wav|ogg)/gi
        ];
        
        for (const pattern of audioUrlPatterns) {
            const matches = html.match(pattern);
            if (matches && matches.length > 0) {
                // Extract the URL from the first match
                let audioUrl = matches[0];
                
                // Clean up the URL if it's in JSON format
                if (audioUrl.includes('"')) {
                    const urlMatch = audioUrl.match(/"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/);
                    if (urlMatch) {
                        audioUrl = urlMatch[1];
                    }
                }
                
                // Clean up data attribute format
                if (audioUrl.includes('data-audio-url=')) {
                    const urlMatch = audioUrl.match(/data-audio-url="([^"]*)"/);
                    if (urlMatch) {
                        audioUrl = urlMatch[1];
                    }
                }
                
                // Clean up src attribute format
                if (audioUrl.includes('src=')) {
                    const urlMatch = audioUrl.match(/src="([^"]*)"/);
                    if (urlMatch) {
                        audioUrl = urlMatch[1];
                    }
                }
                
                // Ensure the URL is properly formatted
                if (audioUrl && !audioUrl.startsWith('http')) {
                    if (audioUrl.startsWith('//')) {
                        audioUrl = 'https:' + audioUrl;
                    } else if (audioUrl.startsWith('/')) {
                        audioUrl = 'https://pixabay.com' + audioUrl;
                    }
                }
                
                console.log(`Extracted audio URL: ${audioUrl}`);
                return audioUrl;
            }
        }
        
        // If no direct audio URL found, look for any MP3/audio references
        const mp3Matches = html.match(/https:\/\/[^"'\s]*\.mp3/gi);
        if (mp3Matches && mp3Matches.length > 0) {
            console.log(`Found MP3 URL: ${mp3Matches[0]}`);
            return mp3Matches[0];
        }
        
        throw new Error('No audio URL found in page content');
        
    } catch (error) {
        console.error(`Failed to extract audio URL from ${pageUrl}:`, error);
        throw error;
    }
}

function showScrapingProgress(message) {
    let progressEl = document.getElementById('pixabay-sound-scraping-progress');
    
    if (!progressEl) {
        progressEl = document.createElement('div');
        progressEl.id = 'pixabay-sound-scraping-progress';
        progressEl.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(75, 194, 75, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            backdrop-filter: blur(10px);
            max-width: 400px;
            text-align: center;
        `;
        document.body.appendChild(progressEl);
    }
    
    progressEl.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px; flex-direction: column;">
            <div style="
                width: 24px;
                height: 24px;
                border: 3px solid rgba(255,255,255,0.3);
                border-top: 3px solid white;
                border-radius: 50%;
                animation: spin 1s linear infinite;
            "></div>
            <div>${message}</div>
        </div>
        <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;
}

function hideScrapingProgress() {
    const progressEl = document.getElementById('pixabay-sound-scraping-progress');
    if (progressEl) {
        progressEl.remove();
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeContentScript);
} else {
    initializeContentScript();
}

// Handle page navigation (for single-page app behavior)
let currentUrl = window.location.href;
setInterval(() => {
    if (window.location.href !== currentUrl) {
        currentUrl = window.location.href;
        isContentScriptActive = false;
        targetInfo = { targetName: 'unknown', targetID: 'unknown', extracted: false }; // Reset target info
        setTimeout(initializeContentScript, 1000);
    }
}, 2000);