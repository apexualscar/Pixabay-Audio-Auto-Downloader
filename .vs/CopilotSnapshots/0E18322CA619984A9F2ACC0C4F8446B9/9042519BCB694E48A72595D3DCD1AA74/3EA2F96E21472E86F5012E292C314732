// Background service worker for Pixabay Sound Effects Downloader - Focused Audio Extraction
console.log('Pixabay Sound Effects Downloader background script loaded');

// Download control variables
let isDownloadPaused = false;
let isDownloadCanceled = false;
let currentDownloadSession = null;
let downloadQueue = [];
let scannedSoundEffects = []; // Store scanned items separately

// Scanning control variables
let currentScanSession = null;
let isScanInProgress = false;

// Configuration variables
let downloadConfig = {
    downloadLocation: 'downloads',
    customLocationPath: '',
    mainFolderName: 'PixabayAudio',
    sortIntoUserFolders: true,
    fileNamingPattern: 'title_id',
    audioQuality: 'highest',
    downloadDelay: 2
};

// Popup state persistence variables
let extensionState = {
    isScanning: false,
    isDownloading: false,
    isPaused: false,
    scannedItems: [],
    currentProgress: { current: 0, total: 0 },
    lastStatus: { icon: 'i', message: 'Ready', type: '' },
    currentTab: null
};

// Listen for messages from popup and content scripts
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    switch (message.action) {
        case 'GET_EXTENSION_STATE':
            sendResponse({ state: extensionState });
            break;
        case 'UPDATE_CONFIG':
            handleConfigUpdate(message.config);
            sendResponse({ success: true });
            break;
        case 'START_SOUND_EFFECTS_SCAN':
            handleSoundEffectsScan(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'START_DOWNLOAD':
            handleStartDownload(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'PAUSE_DOWNLOAD':
            pauseDownload();
            sendResponse({ success: true });
            break;
        case 'RESUME_DOWNLOAD':
            resumeDownload();
            sendResponse({ success: true });
            break;
        case 'CANCEL_DOWNLOAD':
            cancelDownload();
            sendResponse({ success: true });
            break;
        case 'GET_USER_INFO':
            getUserInfoFromPage(message.tabId);
            sendResponse({ success: true });
            break;
        case 'SOUND_EFFECTS_EXTRACTED':
            handleSoundEffectsExtracted(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'SCANNING_ERROR':
            handleScanningError(message);
            sendResponse({ success: true });
            break;
        case 'SET_AUTO_LIKE':
            setAutoLikeSetting(message.enabled);
            sendResponse({ success: true });
            break;
        case 'GET_AUTO_LIKE':
            getAutoLikeSetting().then(enabled => {
                sendResponse({ enabled: enabled });
            });
            return true;
            break;
    }
    return true;
});

// Handle extension installation
chrome.runtime.onInstalled.addListener(async (details) => {
    if (details.reason === 'install') {
        console.log('Pixabay Sound Effects Downloader installed');
        await chrome.storage.local.set({
            'firstInstall': true,
            'installDate': new Date().toISOString(),
            'scrapingMode': 'sound-effects',
            'autoLikeEnabled': false,
            'version': '3.1',
            // Set default configuration
            'downloadLocation': 'downloads',
            'customLocationPath': '',
            'mainFolderName': 'PixabayAudio',
            'sortIntoUserFolders': true,
            'fileNamingPattern': 'title_id',
            'audioQuality': 'highest',
            'downloadDelay': 2
        });
    }
    
    // Load configuration after installation or update
    await loadConfiguration();
});

// Load configuration on startup
chrome.runtime.onStartup.addListener(async () => {
    await loadConfiguration();
});

// Load configuration immediately when service worker starts
(async () => {
    await loadConfiguration();
})();

// Load configuration on startup
async function loadConfiguration() {
    try {
        const result = await chrome.storage.local.get([
            'downloadLocation',
            'customLocationPath',
            'mainFolderName',
            'sortIntoUserFolders',
            'fileNamingPattern',
            'audioQuality',
            'downloadDelay'
        ]);
        
        downloadConfig = {
            downloadLocation: result.downloadLocation || 'downloads',
            customLocationPath: result.customLocationPath || '',
            mainFolderName: result.mainFolderName || 'PixabayAudio',
            sortIntoUserFolders: result.sortIntoUserFolders !== undefined ? result.sortIntoUserFolders : true,
            fileNamingPattern: result.fileNamingPattern || 'title_id',
            audioQuality: result.audioQuality || 'highest',
            downloadDelay: result.downloadDelay || 2
        };
        
        console.log('Configuration loaded:', downloadConfig);
    } catch (error) {
        console.error('Error loading configuration:', error);
    }
}

function handleConfigUpdate(config) {
    downloadConfig = { ...downloadConfig, ...config };
    console.log('Configuration updated:', downloadConfig);
}

function generateFilename(soundEffect, index) {
    const title = sanitizeFilename(soundEffect.title || `sound_effect_${index}`);
    const id = soundEffect.id || index;
    
    switch (downloadConfig.fileNamingPattern) {
        case 'title_id':
            return `${title}_${id}`;
        case 'id_title':
            return `${id}_${title}`;
        case 'title_only':
            return title;
        case 'id_only':
            return id.toString();
        case 'custom':
            // Could implement custom pattern in the future
            return `${title}_${id}`;
        default:
            return `${title}_${id}`;
    }
}

function getFolderPath(pageInfo) {
    let folderPath = downloadConfig.mainFolderName;
    
    if (downloadConfig.sortIntoUserFolders && pageInfo) {
        const cleanTargetName = sanitizeFilename(pageInfo.targetName);
        const pageStr = pageInfo.pageNumber > 1 ? `_Page${pageInfo.pageNumber}` : '';
        
        if (downloadConfig.downloadLocation === 'custom' && downloadConfig.customLocationPath) {
            folderPath = `${downloadConfig.customLocationPath}/${downloadConfig.mainFolderName}/${cleanTargetName}${pageStr}`;
        } else {
            folderPath = `${downloadConfig.mainFolderName}/${cleanTargetName}${pageStr}`;
        }
    } else {
        if (downloadConfig.downloadLocation === 'custom' && downloadConfig.customLocationPath) {
            folderPath = `${downloadConfig.customLocationPath}/${downloadConfig.mainFolderName}`;
        }
    }
    
    return folderPath;
}

// Listen for tab changes and close events to cancel scans
chrome.tabs.onActivated.addListener((activeInfo) => {
    // Cancel scan if user switches tabs
    if (isScanInProgress && currentScanSession) {
        console.log('Tab switched, canceling scan');
        cancelCurrentScan();
    }
});

chrome.tabs.onRemoved.addListener((tabId) => {
    // Cancel scan if tab is closed
    if (isScanInProgress && extensionState.currentTab === tabId) {
        console.log('Tab closed, canceling scan');
        cancelCurrentScan();
    }
});

// Update extension state helper
function updateExtensionState(updates) {
    extensionState = { ...extensionState, ...updates };
    console.log('Extension state updated:', extensionState);
}

function cancelCurrentScan() {
    if (isScanInProgress && currentScanSession) {
        console.log('Canceling current scan session');
        
        // Send cancel message to content script
        if (extensionState.currentTab) {
            chrome.tabs.sendMessage(extensionState.currentTab, {
                action: 'CANCEL_SCAN'
            }).catch(() => {
                // Ignore errors if tab is closed or content script not available
            });
        }
        
        // Update state
        isScanInProgress = false;
        currentScanSession = null;
        updateExtensionState({
            isScanning: false,
            lastStatus: { icon: 'X', message: 'Scan cancelled', type: 'warning' }
        });
        
        // Notify popup
        sendMessageToPopup({
            action: 'SCANNING_ERROR',
            error: 'Scan cancelled due to tab change'
        });
    }
}

async function getUserInfoFromPage(tabId) {
    try {
        // Inject script to extract user info from the current page
        const results = await chrome.scripting.executeScript({
            target: { tabId: tabId },
            function: extractUserInfoFromPage
        });
        
        if (results && results[0] && results[0].result) {
            const userInfo = results[0].result;
            
            // Send user info to popup
            try {
                await chrome.runtime.sendMessage({
                    action: 'USER_INFO_RECEIVED',
                    userInfo: userInfo
                });
            } catch (error) {
                console.log('Could not send user info to popup (popup may be closed)');
            }
        }
    } catch (error) {
        console.error('Error getting user info from page:', error);
    }
}

// Function to be injected into the page to extract user info with correct selectors
function extractUserInfoFromPage() {
    try {
        // Extract username from URL
        const urlMatch = window.location.pathname.match(/\/users\/([^\/\?]+)/);
        let username = urlMatch ? decodeURIComponent(urlMatch[1]) : null;
        
        // Try to get user info from DOM elements with correct selectors
        let userImageURL = '';
        let displayName = '';
        let userId = '';
        let isLoggedIn = false;
        
        // Look for user avatar using the specific class you provided - use the SECOND instance
        const avatarElements = document.querySelectorAll('.image--vdlQM');
        console.log(`Found ${avatarElements.length} elements with class "image--vdlQM"`);
        
        if (avatarElements.length >= 2) {
            // Use the second instance (index 1) as requested
            const avatarEl = avatarElements[1];
            if (avatarEl && avatarEl.src) {
                userImageURL = avatarEl.src;
                console.log(`Found avatar using second instance of .image--vdlQM selector`);
            }
        } else if (avatarElements.length === 1) {
            // Fallback to first if only one exists
            const avatarEl = avatarElements[0];
            if (avatarEl && avatarEl.src) {
                userImageURL = avatarEl.src;
                console.log(`Found avatar using first instance of .image--vdlQM selector`);
            }
        }
        
        // Look for username using the specific class you provided
        const nameSelectors = [
            '.h1--bZ6EI.L--opXRs', // Primary selector for user name
            '.h1--bZ6EI',          // Fallback without second class
            'h1.h1--bZ6EI',        // With h1 tag
            '.user-name',
            '.profile-name',
            'h1',
            'h2'
        ];
        
        for (const selector of nameSelectors) {
            const nameEl = document.querySelector(selector);
            if (nameEl && nameEl.textContent?.trim()) {
                displayName = nameEl.textContent.trim();
                console.log(`Found name using selector: ${selector} - "${displayName}"`);
                break;
            }
        }
        
        // IMPROVED: Check for login status by looking for "Logout" text visibility
        isLoggedIn = checkLoginStatus();
        
        // Extract user ID from URL or page elements
        if (urlMatch) {
            userId = urlMatch[1];
        }
        
        // If we found display name but no username from URL, use display name
        if (!username && displayName) {
            username = displayName;
        }
        
        // If we found username from URL but no display name, use username
        if (username && !displayName) {
            displayName = username;
        }
        
        console.log('Extracted user info:', {
            username: username,
            displayName: displayName,
            userImageURL: userImageURL,
            userId: userId,
            isLoggedIn: isLoggedIn
        });
        
        if (username || displayName) {
            return {
                username: username || displayName,
                displayName: displayName || username,
                userImageURL: userImageURL,
                userId: userId,
                isLoggedIn: isLoggedIn,
                profileUrl: window.location.href
            };
        }
        
        return { isLoggedIn: isLoggedIn };
    } catch (error) {
        console.error('Error extracting user info:', error);
        return null;
    }
}

// Function to extract page information and create organized folder structure
function extractPageInfoFromPage() {
    try {
        const url = window.location.href;
        const pathname = window.location.pathname;
        const searchParams = new URLSearchParams(window.location.search);
        
        // Extract target information
        let targetName = 'unknown';
        let targetID = 'unknown';
        
        // Extract username and ID from URL
        const userMatch = pathname.match(/\/users\/([^\/\?]+)/);
        if (userMatch) {
            targetName = userMatch[1];
            targetID = userMatch[1]; // Use username as ID if no numeric ID found
        }
        
        // Try to extract numeric user ID from page elements
        const userIdSelectors = [
            '[data-user-id]',
            '[data-id]',
            '.user-id',
            '#user-id'
        ];
        
        for (const selector of userIdSelectors) {
            const element = document.querySelector(selector);
            if (element) {
                const id = element.getAttribute('data-user-id') || 
                          element.getAttribute('data-id') || 
                          element.textContent?.trim();
                if (id && /^\d+$/.test(id)) {
                    targetID = id;
                    break;
                }
            }
        }
        
        // Extract page number from URL parameters or pagination
        let pageNumber = 1;
        
        // Check URL parameters
        const pageParam = searchParams.get('page') || 
                         searchParams.get('p') || 
                         searchParams.get('pagi');
        if (pageParam && /^\d+$/.test(pageParam)) {
            pageNumber = parseInt(pageParam);
        }
        
        // Check pagination elements on page
        if (pageNumber === 1) {
            const paginationSelectors = [
                '.pagination .active',
                '.pagination .current',
                '.page-current',
                '.current-page',
                '[aria-current="page"]'
            ];
            
            for (const selector of paginationSelectors) {
                const pageEl = document.querySelector(selector);
                if (pageEl) {
                    const pageText = pageEl.textContent?.trim();
                    if (pageText && /^\d+$/.test(pageText)) {
                        pageNumber = parseInt(pageText);
                        break;
                    }
                }
            }
        }
        
        // Count elements on current page to determine range
        let elementCount = 0;
        
        // Count sound effect elements using the same selectors as the scanner
        const overlayContainers = document.querySelectorAll('.overlayContainer--0ZpHP.lazyImg--u6+yh');
        const audioRows = document.querySelectorAll('.audioRow--nAm4Z');
        
        elementCount = Math.max(overlayContainers.length, audioRows.length);
        
        // If no elements found with specific selectors, try generic counting
        if (elementCount === 0) {
            const genericSelectors = [
                '[class*="overlayContainer"]',
                '[class*="audioRow"]',
                '.audio-item',
                '.sound-item',
                '.media-item'
            ];
            
            for (const selector of genericSelectors) {
                const elements = document.querySelectorAll(selector);
                if (elements.length > 0) {
                    elementCount = elements.length;
                    break;
                }
            }
        }
        
        // Calculate element range
        const startElement = ((pageNumber - 1) * elementCount) + 1;
        const endElement = startElement + elementCount - 1;
        
        console.log('Extracted page info:', {
            targetName,
            targetID,
            pageNumber,
            elementCount,
            elementRange: `${startElement}-${endElement}`
        });
        
        return {
            targetName: sanitizeFilename(targetName),
            targetID: sanitizeFilename(targetID),
            pageNumber: pageNumber,
            elementCount: elementCount,
            elementRange: `${startElement}-${endElement}`
        };
        
    } catch (error) {
        console.error('Error extracting page info:', error);
        return {
            targetName: 'unknown',
            targetID: 'unknown',
            pageNumber: 1,
            elementCount: 0,
            elementRange: '1-0'
        };
    }
}

// Function to check login status by looking for "Logout" text
function checkLoginStatus() {
    try {
        // Look for "Logout" text in various elements
        const logoutSelectors = [
            // Direct text content
            '*[textContent*="Logout"]',
            '*[innerText*="Logout"]',
            // Common logout selectors
            'a[href*="logout"]',
            'button[title*="logout"]',
            'button[aria-label*="logout"]',
            '[data-testid*="logout"]',
            // Menu items
            '.menu-item:has-text("Logout")',
            '.dropdown-item:has-text("Logout")',
            // Generic button/link with logout
            'button:contains("Logout")',
            'a:contains("Logout")'
        ];
        
        // Search for elements containing "Logout" text
        const allElements = document.querySelectorAll('*');
        for (const element of allElements) {
            const text = element.textContent || element.innerText || '';
            if (text.includes('Logout') || text.includes('logout')) {
                // Check if the element is visible
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                
                const isVisible = (
                    rect.width > 0 && 
                    rect.height > 0 &&
                    style.display !== 'none' &&
                    style.visibility !== 'hidden' &&
                    style.opacity !== '0'
                );
                
                if (isVisible) {
                    console.log(`Found visible "Logout" text - user is logged in: "${text.trim()}"`);
                    return true;
                }
            }
        }
        
        // Also check for common logout selectors
        for (const selector of logoutSelectors) {
            try {
                const element = document.querySelector(selector);
                if (element) {
                    const rect = element.getBoundingClientRect();
                    const style = window.getComputedStyle(element);
                    
                    const isVisible = (
                        rect.width > 0 && 
                        rect.height > 0 &&
                        style.display !== 'none' &&
                        style.visibility !== 'hidden' &&
                        style.opacity !== '0'
                    );
                    
                    if (isVisible) {
                        console.log(`Found visible logout element - user is logged in: ${selector}`);
                        return true;
                    }
                }
            } catch (error) {
                // Continue with next selector
            }
        }
        
        console.log('No visible "Logout" elements found - user appears to be logged out');
        return false;
    } catch (error) {
        console.error('Error checking login status:', error);
        return false;
    }
}

// Handle sound effects scan with better error handling and timing
async function handleSoundEffectsScan(request, tabId) {
    const { tabId: requestTabId } = request;
    const targetTabId = requestTabId || tabId;
    
    // Cancel any existing scan
    if (isScanInProgress) {
        console.log('Canceling existing scan before starting new one');
        cancelCurrentScan();
        await sleep(500); // Increased delay to allow cleanup
    }
    
    try {
        console.log('Starting sound effects scan...');
        
        // First, check if we can communicate with the tab
        try {
            await chrome.tabs.get(targetTabId);
        } catch (error) {
            throw new Error('Tab is not accessible or has been closed');
        }
        
        // Create new scan session
        currentScanSession = Date.now();
        isScanInProgress = true;
        
        // Update state
        updateExtensionState({
            isScanning: true,
            isDownloading: false,
            currentTab: targetTabId,
            lastStatus: { icon: 'Search', message: 'Preparing to scan for sound effects...', type: 'success' }
        });
        
        // Add longer delay before communication to avoid Cloudflare issues
        await sleep(1000);
        
        // Set timeout for scan (45 seconds max - increased from 30)
        const scanTimeout = setTimeout(() => {
            if (isScanInProgress && currentScanSession) {
                console.log('Scan timeout reached');
                cancelCurrentScan();
            }
        }, 45000);
        
        // Send message to content script to start scanning with retry logic
        let communicationSuccess = false;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (!communicationSuccess && retryCount < maxRetries) {
            try {
                updateExtensionState({
                    lastStatus: { icon: 'Search', message: `Connecting to page... (attempt ${retryCount + 1})`, type: 'success' }
                });
                
                await chrome.tabs.sendMessage(targetTabId, {
                    action: 'SCAN_SOUND_EFFECTS'
                });
                
                communicationSuccess = true;
                console.log('Successfully communicated with content script');
                
            } catch (error) {
                retryCount++;
                console.log(`Communication attempt ${retryCount} failed:`, error.message);
                
                if (retryCount < maxRetries) {
                    // Wait longer between retries to avoid Cloudflare detection
                    const retryDelay = retryCount * 2000; // 2s, 4s, 6s delays
                    console.log(`Retrying in ${retryDelay}ms...`);
                    await sleep(retryDelay);
                    
                    // Try to inject content script if it's missing
                    try {
                        await chrome.scripting.executeScript({
                            target: { tabId: targetTabId },
                            files: ['content-script.js']
                        });
                        console.log('Re-injected content script');
                        await sleep(1000); // Allow content script to initialize
                    } catch (injectionError) {
                        console.log('Could not re-inject content script:', injectionError.message);
                    }
                } else {
                    clearTimeout(scanTimeout);
                    throw new Error('Could not communicate with page after multiple attempts. The page may have changed or been refreshed. Please try refreshing the page and try again.');
                }
            }
        }
        
        if (!communicationSuccess) {
            clearTimeout(scanTimeout);
            throw new Error('Failed to establish communication with the page');
        }
        
    } catch (error) {
        console.error('Sound effects scan error:', error);
        isScanInProgress = false;
        currentScanSession = null;
        updateExtensionState({
            isScanning: false,
            lastStatus: { icon: 'X', message: error.message, type: 'error' }
        });
        sendMessageToPopup({
            action: 'SCANNING_ERROR',
            error: error.message
        });
    }
}

function handleSoundEffectsExtracted(message, tabId) {
    const { items } = message;
    
    console.log(`Sound effects extracted: ${items.length} items` );
    
    // Clear scan session
    isScanInProgress = false;
    currentScanSession = null;
    
    // Store scanned items for later download
    scannedSoundEffects = items;
    
    // Update state
    updateExtensionState({
        isScanning: false,
        scannedItems: items,
        lastStatus: items.length > 0 
            ? { icon: 'Check', message: `Found ${items.length} sound effects`, type: 'success' }
            : { icon: '!', message: 'No sound effects found on this page', type: 'warning' }
    });
    
    // Forward to popup for display - DO NOT start download automatically
    sendMessageToPopup({
        action: 'SOUND_EFFECTS_SCANNED',
        items: items
    });
    
    if (items.length === 0) {
        sendMessageToPopup({
            action: 'SCANNING_ERROR',
            error: 'No sound effects found on this page'
        });
    }
}

// Handle explicit download start request
async function handleStartDownload(request, tabId) {
    const { tabId: requestTabId } = request;
    const targetTabId = requestTabId || tabId;
    
    if (scannedSoundEffects.length === 0) {
        const errorMsg = 'No sound effects to download. Please scan first.';
        updateExtensionState({
            lastStatus: { icon: 'X', message: errorMsg, type: 'error' }
        });
        sendMessageToPopup({
            action: 'DOWNLOAD_ERROR',
            error: errorMsg
        });
        return;
    }
    
    console.log(`Starting download of ${scannedSoundEffects.length} sound effects`);
    
    // Update state
    updateExtensionState({
        isDownloading: true,
        isPaused: false,
        currentProgress: { current: 0, total: scannedSoundEffects.length },
        lastStatus: { icon: 'Arrow', message: 'Starting download process...', type: 'success' }
    });
    
    await startSoundEffectsDownload(scannedSoundEffects, targetTabId);
}

function handleScanningError(message) {
    console.error('Scanning error:', message.error);
    
    // Clear scan session
    isScanInProgress = false;
    currentScanSession = null;
    
    // Update state
    updateExtensionState({
        isScanning: false,
        lastStatus: { icon: 'X', message: `Scanning failed: ${message.error}`, type: 'error' }
    });
    
    // Forward to popup
    sendMessageToPopup({
        action: 'SCANNING_ERROR',
        error: message.error
    });
}

async function startSoundEffectsDownload(soundEffects, tabId) {
    // Reset download control flags
    isDownloadPaused = false;
    isDownloadCanceled = false;
    currentDownloadSession = Date.now();
    downloadQueue = soundEffects;
    
    try {
        const totalCount = soundEffects.length;
        let downloadedCount = 0;
        
        console.log(`Starting download of ${totalCount} sound effects with anti-Cloudflare measures`);
        
        // Check if auto-like is enabled
        const autoLikeEnabled = await getAutoLikeSetting();
        
        // Check login status at download time (real-time check)
        let userIsLoggedIn = false;
        if (autoLikeEnabled) {
            try {
                const loginCheckResults = await chrome.scripting.executeScript({
                    target: { tabId: tabId },
                    function: checkLoginStatus
                });
                
                if (loginCheckResults && loginCheckResults[0] && loginCheckResults[0].result) {
                    userIsLoggedIn = loginCheckResults[0].result;
                    console.log(`Login check at download time: ${userIsLoggedIn ? 'logged in' : 'logged out'}`);
                }
            } catch (error) {
                console.error('Error checking login status during download:', error);
            }
        }
        
        // Extract page information for organized folder structure
        let pageInfo = null;
        try {
            const pageInfoResults = await chrome.scripting.executeScript({
                target: { tabId: tabId },
                function: extractPageInfoFromPage
            });
            
            if (pageInfoResults && pageInfoResults[0] && pageInfoResults[0].result) {
                pageInfo = pageInfoResults[0].result;
                console.log('Extracted page info for folder structure:', pageInfo);
            }
        } catch (error) {
            console.error('Error extracting page info:', error);
        }
        
        // Auto-like ALL sound effects at once if enabled and user is logged in
        if (autoLikeEnabled && userIsLoggedIn) {
            console.log('Auto-like enabled and user logged in - liking ALL sound effects at once');
            try {
                await chrome.scripting.executeScript({
                    target: { tabId: tabId },
                    function: clickAllLikeButtons
                });
                console.log('Completed liking all sound effects');
                
                // Add longer delay after bulk liking to avoid Cloudflare detection
                await sleep(3000);
                
            } catch (error) {
                console.error('Error during bulk auto-like:', error);
            }
        } else if (autoLikeEnabled && !userIsLoggedIn) {
            console.log('Auto-like enabled but user not logged in - skipping like functionality');
        }
        
        // Notify that download is starting
        sendMessageToPopup({
            action: 'DOWNLOAD_STARTED',
            count: totalCount
        });
        
        // Create organized folder structure based on page info and configuration
        let folderName = getFolderPath(pageInfo);
        
        console.log(`Using configured folder structure: ${folderName}`);
        console.log('Configuration applied:', downloadConfig);
        
        // Enhanced folder creation testing
        let folderWorking = true;
        let folderTestResult = null;
        
        for (let i = 0; i < soundEffects.length; i++) {
            // Check for cancel/pause
            if (isDownloadCanceled) {
                console.log('Download canceled by user');
                break;
            }
            
            while (isDownloadPaused) {
                await sleep(500);
                if (isDownloadCanceled) break;
            }
            
            if (isDownloadCanceled) break;
            
            const soundEffect = soundEffects[i];
            
            try {
                // Apply configured download delay
                const configuredDelay = downloadConfig.downloadDelay * 1000; // Convert to milliseconds
                const randomDelay = Math.random() * 1000; // Random 0-1 seconds
                const totalDelay = configuredDelay + randomDelay;
                
                console.log(`Waiting ${Math.round(totalDelay)}ms before downloading ${soundEffect.id} (configured delay: ${downloadConfig.downloadDelay}s)`);
                await sleep(totalDelay);
                
                // Update status to show which file is being processed
                updateExtensionState({
                    lastStatus: { icon: 'Download', message: `Downloading ${i + 1}/${totalCount}: ${soundEffect.title}`, type: 'success' }
                });
                
                // Test folder structure on first download, then use result for all subsequent downloads
                let useFolderStructure = folderWorking;
                if (i === 0) {
                    // First download - test folder capability
                    console.log('Testing folder creation capability with first download...');
                    useFolderStructure = true;
                } else if (folderTestResult === 'FOLDER_STRUCTURE_FAILED') {
                    // Use the result from first download
                    useFolderStructure = false;
                    console.log(`Using flat structure based on first download test result`);
                }
                
                const result = await downloadSoundEffect(soundEffect, folderName, tabId, useFolderStructure, i);
                
                // Store the result from first download to apply to all subsequent downloads
                if (i === 0) {
                    folderTestResult = result;
                    if (result === 'FOLDER_STRUCTURE_FAILED') {
                        console.log('First download test failed - folder structure not supported. Using flat structure for remaining downloads.');
                        folderWorking = false;
                    } else {
                        console.log('First download test successful - folder structure supported. Using folders for remaining downloads.');
                        folderWorking = true;
                    }
                }
                
                // Count as successful download regardless of folder structure
                if (result === 'FOLDER_STRUCTURE_FAILED' || result === 'NATIVE_DOWNLOAD_TRIGGERED' || result === 'OPENED_IN_NEW_TAB' || typeof result === 'number') {
                    downloadedCount++;
                }
                
                // Update progress and state
                updateExtensionState({
                    currentProgress: { current: downloadedCount, total: totalCount },
                    lastStatus: { icon: 'Download', message: `Downloaded ${downloadedCount}/${totalCount} files`, type: 'success' }
                });
                
                sendMessageToPopup({
                    action: 'UPDATE_PROGRESS',
                    current: downloadedCount,
                    total: totalCount
                });
                
            } catch (error) {
                console.error(`Failed to download ${soundEffect.id}:`, error);
                
                // If this is the first download and it's a folder-related error, disable folder structure
                if (i === 0 && (error.message.includes('path') || error.message.includes('folder') || error.message.includes('directory'))) {
                    console.log('First download failed due to folder issues - disabling folder structure for all downloads');
                    folderWorking = false;
                    folderTestResult = 'FOLDER_STRUCTURE_FAILED';
                    
                    // Retry this download with flat structure
                    try {
                        console.log(`Retrying first download with flat structure...`);
                        await sleep(1000); // Brief delay before retry
                        const retryResult = await downloadSoundEffect(soundEffect, folderName, tabId, false, i);
                        if (retryResult) {
                            downloadedCount++;
                        }
                    } catch (retryError) {
                        console.error(`Retry also failed for ${soundEffect.id}:`, retryError);
                    }
                } else {
                    // For subsequent downloads or non-folder errors, just continue
                    console.log(`Skipping ${soundEffect.id} due to error, continuing with next file`);
                }
            }
        }
        
        // Update final state
        const finalStatus = isDownloadCanceled 
            ? { icon: 'X', message: `Download canceled. ${downloadedCount || 0} files downloaded.`, type: 'error' }
            : { icon: 'Check', message: `Download complete! ${downloadedCount} sound effects downloaded.`, type: 'success' };
            
        updateExtensionState({
            isDownloading: false,
            isPaused: false,
            lastStatus: finalStatus
        });
        
        // Notify completion or cancellation
        if (isDownloadCanceled) {
            sendMessageToPopup({
                action: 'DOWNLOAD_CANCELED',
                count: downloadedCount
            });
        } else {
            sendMessageToPopup({
                action: 'DOWNLOAD_COMPLETE',
                count: downloadedCount
            });
        }
        
    } catch (error) {
        console.error('Download error:', error);
        updateExtensionState({
            isDownloading: false,
            isPaused: false,
            lastStatus: { icon: 'X', message: `Error: ${error.message}`, type: 'error' }
        });
        sendMessageToPopup({
            action: 'DOWNLOAD_ERROR',
            error: error.message
        });
    }
}

// New function to handle directory creation and downloads
async function downloadWithDirectoryStructure(url, folderPath, filename, useFolderStructure) {
    if (!useFolderStructure) {
        // Use flat structure immediately
        const flatFilename = `${folderPath.replace(/\//g, '_')}_${filename}`;
        return await chromeDownloadFile(url, flatFilename);
    }
    
    // Method 1: Try File System Access API (modern browsers)
    if ('showDirectoryPicker' in window) {
        try {
            console.log('Attempting to use File System Access API for proper folder creation');
            return await downloadUsingFileSystemAPI(url, folderPath, filename);
        } catch (error) {
            console.log('File System Access API failed:', error.message);
            // Continue to Method 2
        }
    }
    
    // Method 2: Try Chrome Downloads API with directory hints
    try {
        console.log('Attempting Chrome Downloads API with directory structure');
        
        // Handle different download locations
        let fullPath;
        const baseLocation = downloadConfig.downloadLocation;
        
        switch (baseLocation) {
            case 'desktop':
                fullPath = `Desktop/${folderPath}/${filename}`;
                break;
            case 'documents':
                fullPath = `Documents/${folderPath}/${filename}`;
                break;
            case 'music':
                fullPath = `Music/${folderPath}/${filename}`;
                break;
            case 'custom':
                if (downloadConfig.customLocationPath) {
                    // Use custom path directly since folderPath already includes it
                    fullPath = `${folderPath}/${filename}`;
                } else {
                    // Fallback to downloads if custom path is empty
                    fullPath = `${folderPath}/${filename}`;
                }
                break;
            case 'downloads':
            default:
                // Use forward slashes for cross-platform compatibility
                const directoryPath = folderPath.replace(/\\/g, '/');
                fullPath = `${directoryPath}/${filename}`;
                break;
        }
        
        console.log(`Attempting download to: ${fullPath}`);
        return await chromeDownloadFile(url, fullPath);
        
    } catch (error) {
        console.log('Chrome Downloads API with folders failed:', error.message);
        
        // Method 3: Fallback to Downloads folder only
        console.log('Falling back to Downloads folder without subdirectories');
        return await chromeDownloadFile(url, filename);
    }
}

// Enhanced Chrome Downloads API function
async function chromeDownloadFile(url, filename) {
    return new Promise((resolve, reject) => {
        console.log(`Chrome Downloads API: Downloading "${filename}" from ${url}`);
        
        // Validate URL before attempting download
        if (!url || !url.startsWith('http')) {
            reject(new Error(`Invalid download URL: ${url}`));
            return;
        }
        
        // Validate filename
        if (!filename) {
            filename = `download_${Date.now()}.mp3`;
        }
        
        // CRITICAL FIX: Ensure proper path handling for different operating systems
        let processedFilename = filename;
        
        // Handle folder structure more explicitly
        if (filename.includes('/')) {
            // Split the path and ensure each part is valid
            const pathParts = filename.split('/');
            const validParts = pathParts.map(part => {
                // Sanitize each path component
                return part.replace(/[<>:"|?*]/g, '_').replace(/\./g, '_').trim();
            }).filter(part => part.length > 0);
            
            if (validParts.length > 1) {
                processedFilename = validParts.join('/');
                console.log(`Processed folder path: ${processedFilename}`);
            } else {
                processedFilename = validParts[0] || `download_${Date.now()}.mp3`;
                console.log(`Flattened to single filename: ${processedFilename}`);
            }
        }
        
        chrome.downloads.download({
            url: url,
            filename: processedFilename,
            saveAs: false,
            conflictAction: 'uniquify'
        }, (downloadId) => {
            if (chrome.runtime.lastError) {
                const errorMessage = chrome.runtime.lastError.message;
                console.error(`Download failed for ${processedFilename}:`, errorMessage);
                
                // If this was a folder-related error, try with flattened structure
                if (errorMessage.toLowerCase().includes('path') || 
                    errorMessage.toLowerCase().includes('directory') || 
                    errorMessage.toLowerCase().includes('folder') ||
                    errorMessage.toLowerCase().includes('invalid filename') ||
                    errorMessage.toLowerCase().includes('file name') ||
                    processedFilename.includes('/')) {
                    
                    // Create a flattened filename that includes folder info
                    const flatFilename = processedFilename.replace(/\//g, '_');
                    console.log(`Retrying download with flattened filename: ${flatFilename}`);
                    
                    chrome.downloads.download({
                        url: url,
                        filename: flatFilename,
                        saveAs: false,
                        conflictAction: 'uniquify'
                    }, (retryDownloadId) => {
                        if (chrome.runtime.lastError) {
                            console.error(`Retry also failed:`, chrome.runtime.lastError.message);
                            reject(new Error(chrome.runtime.lastError.message));
                        } else {
                            console.log(`Retry successful with flat structure: ${retryDownloadId} - ${flatFilename}`);
                            resolve('FOLDER_STRUCTURE_FAILED');
                        }
                    });
                } else {
                    reject(new Error(errorMessage));
                }
            } else {
                console.log(`Download started successfully: ${downloadId} - ${processedFilename}`);
                resolve(downloadId);
            }
        });
    });
}

// Function to click ALL like buttons for ALL sound effects at once
function clickAllLikeButtons() {
    try {
        console.log('Starting bulk auto-like for ALL sound effects');
        
        let likedCount = 0;
        
        // Method 1: Look for like buttons within likeButtonWrapper elements
        const likeWrappers = document.querySelectorAll('.likeButtonWrapper--yrNJw');
        console.log(`Found ${likeWrappers.length} like button wrappers`);
        
        likeWrappers.forEach((wrapper, index) => {
            try {
                // Find the like button within this wrapper
                const likeButton = wrapper.querySelector('.button--9NFL8.square--n2VLb.light--C3NP-.center--ZZf40');
                if (likeButton) {
                    console.log(`Clicking like button ${index + 1} in wrapper`);
//                   likeButton.click();
                    likedCount++;
                } else {
                    console.log(`No like button found in wrapper ${index + 1}`);
                }
            } catch (error) {
                console.error(`Error clicking like button in wrapper ${index + 1}:`, error);
            }
        });
        
        // Method 2: Fallback - find all like buttons and group by containers
        if (likedCount === 0) {
            console.log('No wrappers found, using fallback method');
            
            const allLikeButtons = document.querySelectorAll('.button--9NFL8.square--n2VLb.light--C3NP-.center--ZZf40');
            console.log(`Found ${allLikeButtons.length} total like buttons on page`);
            
            // Group buttons by their parent containers to avoid duplicates
            const containerButtonMap = new Map();
            
            allLikeButtons.forEach((button, index) => {
                try {
                    // Find the sound effect container
                    const container = button.closest('.overlayContainer--0ZpHP, .audioRow--nAm4Z, .media-item, .item-container, [data-testid="media-item"], .likeButtonWrapper--yrNJw');
                    
                    if (container) {
                        // Only store one button per container (to avoid clicking multiple buttons in same item)
                        if (!containerButtonMap.has(container)) {
                            containerButtonMap.set(container, button);
                        }
                    } else {
                        // If no container found, click the button directly
                        console.log(`Clicking standalone like button ${index + 1}`);
                        button.click();
                        likedCount++;
                    }
                } catch (error) {
                    console.error(`Error processing like button ${index + 1}:`, error);
                }
            });
            
            // Click one button per container
            containerButtonMap.forEach((button, container) => {
                try {
                    console.log(`Clicking like button in container`);
                    button.click();
                    likedCount++;
                } catch (error) {
                    console.error('Error clicking like button in container:', error);
                }
            });
        }
        
        // Method 3: Ultimate fallback - click all heart/like icons
        if (likedCount === 0) {
            console.log('Still no likes, trying ultimate fallback');
            
            // Look for heart icons or other like indicators
            const heartSelectors = [
                '[aria-label*="like"]',
                '[title*="like"]',
                '[data-testid*="like"]',
                '.fa-heart',
                '.heart-icon',
                'svg[class*="heart"]',
                'button[class*="like"]'
            ];
            
            for (const selector of heartSelectors) {
                try {
                    const elements = document.querySelectorAll(selector);
                    console.log(`Found ${elements.length} elements with selector: ${selector}`);
                    
                    elements.forEach((element, index) => {
                        try {
                            // Check if the element is visible
                            const rect = element.getBoundingClientRect();
                            const style = window.getComputedStyle(element);
                            
                            const isVisible = (
                                rect.width > 0 && 
                                rect.height > 0 &&
                                style.display !== 'none' &&
                                style.visibility !== 'hidden' &&
                                style.opacity !== '0'
                            );
                            
                            if (isVisible) {
                                console.log(`Clicking visible like/heart icon ${index + 1}`);
                                element.click();
                                likedCount++;
                            } else {
                                console.log(`Like/heart icon ${index + 1} is not visible`);
                            }
                        } catch (error) {
                            console.error(`Error clicking like/heart icon ${index + 1}:`, error);
                        }
                    });
                } catch (error) {
                    console.error(`Error processing selector ${selector}:`, error);
                }
            }
        }
        
        console.log(`Bulk auto-like completed. Total liked: ${likedCount}`);
    } catch (error) {
        console.error('Error in bulk auto-like function:', error);
    }
}

async function downloadSoundEffect(soundEffect, folderName, tabId, useFolderStructure = true, index = 0) {
    try {
        console.log(`Processing sound effect ${soundEffect.id} (index ${index}):`);
        console.log(`- Individual URL: ${soundEffect.pageUrl || soundEffect.downloadUrl}`);
        console.log(`- Profile URL: ${soundEffect.profileUrl || 'N/A'}`);
        console.log(`- Title: ${soundEffect.title}`);
        
        // Validate that we have unique data for this sound effect
        if (!soundEffect.id || soundEffect.id === 'sound_0' || soundEffect.id.startsWith('sound_') && soundEffect.id.length < 10) {
            console.log(`Warning: Sound effect has generic ID: ${soundEffect.id}, using index-based ID`);
            soundEffect.id = `sound_${Date.now()}_${index}`;
        }
        
        // Method 1: Try to navigate to individual page and click download button (PREFERRED)
        const individualPageUrl = soundEffect.pageUrl || soundEffect.downloadUrl;
        
        if (individualPageUrl && individualPageUrl !== soundEffect.profileUrl) {
            // Check if this looks like an individual sound effect page
            const isIndividualPage = individualPageUrl.match(/\/music-\d+\/|\/sound-effect-\d+\/|\/audio-\d+\//) ||
                                   (individualPageUrl.includes('/music/') && individualPageUrl.match(/\/\d+/)) ||
                                   (individualPageUrl.includes('/sound-effects/') && individualPageUrl.match(/\/\d+/)) ||
                                   (individualPageUrl.includes('/audio/') && individualPageUrl.match(/\/\d+/));
            
            if (isIndividualPage) {
                console.log(`Attempting to navigate to individual page and click download: ${individualPageUrl}`);
                
                try {
                    // Open individual page in the same tab
                    await chrome.tabs.update(tabId, { url: individualPageUrl });
                    
                    // Wait for navigation to complete
                    await sleep(3000);
                    
                    // Now try to click the download button
                    const result = await chrome.scripting.executeScript({
                        target: { tabId: tabId },
                        function: clickDownloadButtonOnPage,
                        args: [individualPageUrl, soundEffect.id]
                    });
                    
                    if (result && result[0] && result[0].result) {
                        const clickResult = result[0].result;
                        console.log(`Button click result: ${clickResult}`);
                        
                        if (clickResult.includes('SUCCESS')) {
                            console.log(`Successfully triggered download via navigation and button click for ${soundEffect.id}`);
                            
                            // Wait a bit for download to start, then navigate back
                            await sleep(2000);
                            
                            // Navigate back to profile page for next download
                            if (soundEffect.profileUrl) {
                                await chrome.tabs.update(tabId, { url: soundEffect.profileUrl });
                                await sleep(2000); // Wait for navigation back
                            }
                            
                            return 'NATIVE_DOWNLOAD_TRIGGERED';
                        }
                    }
                } catch (error) {
                    console.log(`Navigation and button click failed for ${soundEffect.id}: ${error.message}`);
                    
                    // Navigate back to profile page on error
                    if (soundEffect.profileUrl) {
                        try {
                            await chrome.tabs.update(tabId, { url: soundEffect.profileUrl });
                            await sleep(2000);
                        } catch (navError) {
                            console.log(`Error navigating back to profile: ${navError.message}`);
                        }
                    }
                }
            } else {
                console.log(`URL does not appear to be an individual page: ${individualPageUrl}`);
            }
        }
        
        console.log(`Button clicking method failed for ${soundEffect.id}, falling back to Chrome Downloads API...`);
        
        // Method 2: Use Chrome Downloads API with URL extraction
        let downloadUrl = soundEffect.downloadUrl || soundEffect.pageUrl;
        
        // Check if we have a direct audio file URL
        const isDirectAudioUrl = downloadUrl && (
            downloadUrl.includes('.mp3') || 
            downloadUrl.includes('.wav') || 
            downloadUrl.includes('.ogg') ||
            downloadUrl.includes('.aac') ||
            downloadUrl.includes('.m4a') ||
            downloadUrl.includes('.flac')
        );
        
        // If we don't have a direct audio URL, try to extract from page
        if (!isDirectAudioUrl && individualPageUrl) {
            console.log(`No direct audio URL found, attempting to extract from page: ${individualPageUrl}`);
            
            try {
                const extractedUrl = await extractAudioUrlFromPage(individualPageUrl);
                if (extractedUrl && extractedUrl !== 'BUTTON_CLICKED') {
                    downloadUrl = extractedUrl;
                    console.log(`Successfully extracted audio URL: ${downloadUrl}`);
                } else if (extractedUrl === 'BUTTON_CLICKED') {
                    console.log(`Download was triggered by button click during URL extraction, no further action needed`);
                    return 'NATIVE_DOWNLOAD_TRIGGERED';
                }
            } catch (error) {
                console.log(`Failed to extract audio URL from page: ${error.message}`);
            }
        }
        
        // If still no direct audio URL, try preview URL as fallback
        if (!downloadUrl || !downloadUrl.match(/\.(?:mp3|wav|ogg|aac|m4a|flac)(?:\?|$)/i)) {
            if (soundEffect.previewUrl) {
                console.log(`Using preview URL as fallback: ${soundEffect.previewUrl}`);
                downloadUrl = soundEffect.previewUrl;
            } else {
                throw new Error(`No downloadable URL found for ${soundEffect.id} after trying all methods`);
            }
        }
        
        // Validate that we have a downloadable URL and it's not an image
        if (!downloadUrl) {
            throw new Error(`No downloadable URL found for ${soundEffect.id}`);
        }
        
        if (downloadUrl.includes('/photo/') || 
            downloadUrl.includes('/illustration/') || 
            downloadUrl.includes('/vector/') ||
            downloadUrl.match(/\.(?:jpg|jpeg|png|gif|webp|bmp)$/i)) {
            throw new Error(`Download URL appears to be an image, not an audio file: ${downloadUrl}`);
        }
        
        console.log(`Using Chrome downloads API for ${soundEffect.id} with URL: ${downloadUrl}`);
        
        // Create filename with configured pattern and proper extension detection
        const baseFilename = generateFilename(soundEffect, index);
        let extension = getFileExtensionFromUrl(downloadUrl);
        
        // If extension detection fails, try to determine from content type
        if (!extension || !['mp3', 'wav', 'ogg', 'aac', 'm4a', 'flac'].includes(extension)) {
            try {
                const response = await fetch(downloadUrl, { 
                    method: 'HEAD',
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });
                const contentType = response.headers.get('content-type');
                if (contentType) {
                    if (contentType.includes('audio/mpeg')) extension = 'mp3';
                    else if (contentType.includes('audio/wav')) extension = 'wav';
                    else if (contentType.includes('audio/ogg')) extension = 'ogg';
                    else if (contentType.includes('audio/aac')) extension = 'aac';
                    else if (contentType.includes('audio/mp4')) extension = 'm4a';
                    else if (contentType.includes('audio/')) extension = 'mp3'; // Generic audio fallback
                    else extension = 'mp3'; // Default fallback
                } else {
                    extension = 'mp3'; // Default fallback
                }
            } catch (error) {
                console.log(`Could not determine content type for ${downloadUrl}, using mp3`);
                extension = 'mp3';
            }
        }
        
        const fullFilename = `${baseFilename}.${extension}`;
        console.log(`Generated filename: ${fullFilename} using pattern: ${downloadConfig.fileNamingPattern}`);
        
        // Use the improved directory structure handling
        return await downloadWithDirectoryStructure(downloadUrl, folderName, fullFilename, useFolderStructure);
        
    } catch (error) {
        console.error(`Error processing sound effect ${soundEffect.id}:`, error);
        throw error;
    }
}

// File System Access API implementation (for modern browsers)
async function downloadUsingFileSystemAPI(url, folderPath, filename) {
    try {
        // This would require user permission to access directories
        // For now, we'll skip this approach as it requires user interaction
        throw new Error('File System Access API requires user interaction');
        
        // Future implementation would look like:
        // const dirHandle = await window.showDirectoryPicker();
        // const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
        // const writable = await fileHandle.createWritable();
        // const response = await fetch(url);
        // await response.body.pipeTo(writable);
        
    } catch (error) {
        throw new Error(`File System Access API not available: ${error.message}`);
    }
}

// Extract audio URL from page (placeholder function)
async function extractAudioUrlFromPage(pageUrl) {
    try {
        console.log(`Attempting to extract audio URL from: ${pageUrl}`);
        
        // Fetch the page content
        const response = await fetch(pageUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            signal: AbortSignal.timeout(10000) // 10 second timeout
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const html = await response.text();
        
        // Look for common patterns in Pixabay's HTML that contain audio URLs
        const audioUrlPatterns = [
            /"preview":\s*"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"audioURL":\s*"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"download":\s*"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /data-audio-url="([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /src="([^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /https:\/\/cdn\.pixabay\.com\/audio\/[^"']*\.(?:mp3|wav|ogg)/gi,
            /https:\/\/pixabay\.com\/[^"']*\.(?:mp3|wav|ogg)/gi
        ];
        
        for (const pattern of audioUrlPatterns) {
            const matches = html.match(pattern);
            if (matches && matches.length > 0) {
                // Extract the URL from the first match
                let audioUrl = matches[0];
                
                // Clean up the URL if it's in JSON format
                if (audioUrl.includes('"')) {
                    const urlMatch = audioUrl.match(/"([^"]*\.(?:mp3|wav|ogg)[^"]*)"/);
                    if (urlMatch) {
                        audioUrl = urlMatch[1];
                    }
                }
                
                // Clean up data attribute format
                if (audioUrl.includes('data-audio-url=')) {
                    const urlMatch = audioUrl.match(/data-audio-url="([^"]*)"/);
                    if (urlMatch) {
                        audioUrl = urlMatch[1];
                    }
                }
                
                // Clean up src attribute format
                if (audioUrl.includes('src=')) {
                    const urlMatch = audioUrl.match(/src="([^"]*)"/);
                    if (urlMatch) {
                        audioUrl = urlMatch[1];
                    }
                }
                
                // Ensure the URL is properly formatted
                if (audioUrl && !audioUrl.startsWith('http')) {
                    if (audioUrl.startsWith('//')) {
                        audioUrl = 'https:' + audioUrl;
                    } else if (audioUrl.startsWith('/')) {
                        audioUrl = 'https://pixabay.com' + audioUrl;
                    }
                }
                
                console.log(`Extracted audio URL: ${audioUrl}`);
                return audioUrl;
            }
        }
        
        // If no direct audio URL found, look for any MP3/audio references
        const mp3Matches = html.match(/https:\/\/[^"'\s]*\.mp3/gi);
        if (mp3Matches && mp3Matches.length > 0) {
            console.log(`Found MP3 URL: ${mp3Matches[0]}`);
            return mp3Matches[0];
        }
        
        throw new Error('No audio URL found in page content');
        
    } catch (error) {
        console.error(`Failed to extract audio URL from ${pageUrl}:`, error);
        throw error;
    }
}

// Simulate download button click
async function simulateDownloadButtonClick(pageUrl, soundEffectId, tabId) {
    try {
        console.log(`Attempting to simulate download button click for ${soundEffectId} on ${pageUrl}`);
        
        // Execute script in the target tab to click the download button
        const result = await chrome.scripting.executeScript({
            target: { tabId: tabId },
            function: clickDownloadButtonOnPage,
            args: [pageUrl, soundEffectId]
        });
        
        if (result && result[0] && result[0].result) {
            return result[0].result;
        } else {
            throw new Error('No result from button click script');
        }
        
    } catch (error) {
        console.error(`Error simulating download button click for ${soundEffectId}:`, error);
        throw error;
    }
}

// Function to be injected into the page to click download button
function clickDownloadButtonOnPage(targetPageUrl, soundEffectId) {
    try {
        console.log(`Looking for download button for sound effect ${soundEffectId} on page: ${window.location.href}`);
        console.log(`Target page URL: ${targetPageUrl}`);
        
        // Check if we need to navigate to the target page
        if (window.location.href !== targetPageUrl) {
            console.log(`Current page (${window.location.href}) does not match target (${targetPageUrl})`);
            
            // Instead of navigating (which causes issues), return a specific code
            return 'NAVIGATION_NEEDED: Different page detected, will handle differently';
        }
        
        // Wait for page to load completely
        if (document.readyState !== 'complete') {
            console.log('Page not fully loaded, waiting...');
            return 'WAITING: Page still loading';
        }
        
        // Method 1: Find download button using specific classes for audio pages
        const actionButtons = document.querySelector('.actionButtons--NbgQi');
        if (actionButtons) {
            // Look for download button (typically ghost/light colored)
            const downloadButton = actionButtons.querySelector('.button--9NFL8.ghost--wIHwU.light--C3NP-.center--ZZf40') ||
                                 actionButtons.querySelector('.button--9NFL8[class*="ghost"]') ||
                                 actionButtons.querySelector('.button--9NFL8[class*="download"]');
            
            if (downloadButton) {
                console.log('Found download button with specific classes');
                
                // Check if button is visible and clickable
                const rect = downloadButton.getBoundingClientRect();
                const style = window.getComputedStyle(downloadButton);
                
                const isClickable = (
                    rect.width > 0 && 
                    rect.height > 0 &&
                    style.display !== 'none' &&
                    style.visibility !== 'hidden' &&
                    style.opacity !== '0' &&
                    !downloadButton.disabled
                );
                
                if (isClickable) {
                    // Simulate human click with proper events
                    const clickEvent = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true,
                        button: 0
                    });
                    
                    downloadButton.dispatchEvent(clickEvent);
                    downloadButton.click();
                    
                    console.log('Successfully clicked download button');
                    return 'SUCCESS: Download button clicked with specific classes';
                } else {
                    console.log('Download button found but not clickable');
                }
            } else {
                console.log('No download button found in action buttons area');
            }
        } else {
            console.log('No action buttons area found on page');
        }
        
        // Method 2: Look for download-related selectors across the page
        const downloadSelectors = [
            'a[href*="download"]',
            'button[title*="download" i]',
            'button[aria-label*="download" i]',
            '.download-button',
            '.btn-download',
            '[data-testid*="download"]',
            'button:has-text("Download")',
            'a:has-text("Download")'
        ];
        
        for (const selector of downloadSelectors) {
            try {
                const elements = document.querySelectorAll(selector);
                console.log(`Found ${elements.length} elements with selector: ${selector}`);
                
                // Click the first visible and clickable one
                for (const element of elements) {
                    const rect = element.getBoundingClientRect();
                    const style = window.getComputedStyle(element);
                    
                    const isClickable = (
                        rect.width > 0 && 
                        rect.height > 0 &&
                        style.display !== 'none' &&
                        style.visibility !== 'hidden' &&
                        style.opacity !== '0' &&
                        !element.disabled
                    );
                    
                    if (isClickable) {
                        console.log(`Clicking visible download element with selector: ${selector}`);
                        element.click();
                        return `SUCCESS: Download clicked with selector ${selector}`;
                    }
                }
            } catch (error) {
                console.log(`Error with selector ${selector}:`, error.message);
            }
        }
        
        // Method 3: Look for any button in action area that might be download
        if (actionButtons) {
            const allButtons = actionButtons.querySelectorAll('button, a');
            console.log(`Found ${allButtons.length} total buttons in action area`);
            
            for (const button of allButtons) {
                const text = button.textContent || button.title || button.getAttribute('aria-label') || '';
                const href = button.href || '';
                
                // Check if this looks like a download button
                if (text.toLowerCase().includes('download') || 
                    href.toLowerCase().includes('download') ||
                    button.className.toLowerCase().includes('download')) {
                    
                    console.log(`Found potential download button with text: "${text}" and href: "${href}"`);
                    
                    // Check if clickable
                    const rect = button.getBoundingClientRect();
                    const style = window.getComputedStyle(button);
                    
                    const isClickable = (
                        rect.width > 0 && 
                        rect.height > 0 &&
                        style.display !== 'none' &&
                        style.visibility !== 'hidden' &&
                        style.opacity !== '0' &&
                        !button.disabled
                    );
                    
                    if (isClickable) {
                        console.log(`Clicking button with download indication`);
                        button.click();
                        return 'SUCCESS: Download button clicked by content analysis';
                    }
                }
            }
        }
        
        // Method 4: Check if we're on the wrong type of page
        const pageUrl = window.location.href;
        if (pageUrl.includes('/users/') && !pageUrl.match(/\/music-\d+\/|\/sound-effect-\d+\/|\/audio-\d+\//)) {
            console.log('Detected profile page instead of individual sound effect page');
            return 'ERROR: On profile page instead of individual sound effect page';
        }
        
        console.log('No download button found after exhaustive search');
        return 'ERROR: No download button found on individual page';
        
    } catch (error) {
        console.error('Error in clickDownloadButtonOnPage:', error);
        return `ERROR: ${error.message}`;
    }
}

// Utility functions
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function sanitizeFilename(filename) {
    if (!filename) return 'unknown';
    return filename
        .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_')
        .replace(/\s+/g, '_')
        .replace(/_{2,}/g, '_')
        .toLowerCase()
        .substring(0, 50);
}

function getFileExtensionFromUrl(url) {
    if (!url) return 'mp3';
    
    try {
        const pathname = new URL(url).pathname;
        const extension = pathname.split('.').pop();
        return extension && extension.length <= 4 ? extension : 'mp3';
    } catch (error) {
        return 'mp3';
    }
}

// Auto-like settings
async function setAutoLikeSetting(enabled) {
    try {
        await chrome.storage.local.set({ 'autoLikeEnabled': enabled });
        console.log('Auto-like setting saved:', enabled);
    } catch (error) {
        console.error('Error saving auto-like setting:', error);
    }
}

async function getAutoLikeSetting() {
    try {
        const result = await chrome.storage.local.get(['autoLikeEnabled']);
        return result.autoLikeEnabled || false;
    } catch (error) {
        console.error('Error getting auto-like setting:', error);
        return false;
    }
}

// Download control functions
function pauseDownload() {
    isDownloadPaused = true;
    updateExtensionState({
        isPaused: true,
        lastStatus: { icon: 'Pause', message: 'Download paused', type: 'warning' }
    });
    sendMessageToPopup({
        action: 'DOWNLOAD_PAUSED'
    });
}

function resumeDownload() {
    isDownloadPaused = false;
    updateExtensionState({
        isPaused: false,
        lastStatus: { icon: 'Play', message: 'Download resumed', type: 'success' }
    });
    sendMessageToPopup({
        action: 'DOWNLOAD_RESUMED'
    });
}

function cancelDownload() {
    isDownloadCanceled = true;
    isDownloadPaused = false;
    updateExtensionState({
        isDownloading: false,
        isPaused: false,
        lastStatus: { icon: 'X', message: 'Download canceled', type: 'error' }
    });
    sendMessageToPopup({
        action: 'DOWNLOAD_CANCELED'
    });
}

// Helper function to send messages to popup
function sendMessageToPopup(message) {
    try {
        chrome.runtime.sendMessage(message).catch(() => {
            // Ignore errors if popup is closed
            console.log('Could not send message to popup (popup may be closed)');
        });
    } catch (error) {
        console.log('Could not send message to popup:', error.message);
    }
}