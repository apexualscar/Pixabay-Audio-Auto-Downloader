// Background service worker for Pixabay Sound Effects Downloader - Focused Audio Extraction
console.log('Pixabay Sound Effects Downloader background script loaded');

// Download control variables
let isDownloadPaused = false;
let isDownloadCanceled = false;
let currentDownloadSession = null;
let downloadQueue = [];
let scannedSoundEffects = []; // Store scanned items separately

// Listen for messages from popup and content scripts
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    switch (message.action) {
        case 'START_SOUND_EFFECTS_SCAN':
            handleSoundEffectsScan(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'START_DOWNLOAD':
            handleStartDownload(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'PAUSE_DOWNLOAD':
            pauseDownload();
            sendResponse({ success: true });
            break;
        case 'RESUME_DOWNLOAD':
            resumeDownload();
            sendResponse({ success: true });
            break;
        case 'CANCEL_DOWNLOAD':
            cancelDownload();
            sendResponse({ success: true });
            break;
        case 'GET_USER_INFO':
            getUserInfoFromPage(message.tabId);
            sendResponse({ success: true });
            break;
        case 'SOUND_EFFECTS_EXTRACTED':
            handleSoundEffectsExtracted(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'SCANNING_ERROR':
            handleScanningError(message);
            sendResponse({ success: true });
            break;
        case 'SET_AUTO_LIKE':
            setAutoLikeSetting(message.enabled);
            sendResponse({ success: true });
            break;
        case 'GET_AUTO_LIKE':
            getAutoLikeSetting().then(enabled => {
                sendResponse({ enabled: enabled });
            });
            return true;
            break;
    }
    return true;
});

async function getUserInfoFromPage(tabId) {
    try {
        // Inject script to extract user info from the current page
        const results = await chrome.scripting.executeScript({
            target: { tabId: tabId },
            function: extractUserInfoFromPage
        });
        
        if (results && results[0] && results[0].result) {
            const userInfo = results[0].result;
            
            // Send user info to popup
            try {
                await chrome.runtime.sendMessage({
                    action: 'USER_INFO_RECEIVED',
                    userInfo: userInfo
                });
            } catch (error) {
                console.log('Could not send user info to popup (popup may be closed)');
            }
        }
    } catch (error) {
        console.error('Error getting user info from page:', error);
    }
}

// Function to be injected into the page to extract user info with correct selectors
function extractUserInfoFromPage() {
    try {
        // Extract username from URL
        const urlMatch = window.location.pathname.match(/\/users\/([^\/\?]+)/);
        let username = urlMatch ? decodeURIComponent(urlMatch[1]) : null;
        
        // Try to get user info from DOM elements with correct selectors
        let userImageURL = '';
        let displayName = '';
        let userId = '';
        let isLoggedIn = false;
        
        // Look for user avatar using the specific class you provided - use the SECOND instance
        const avatarElements = document.querySelectorAll('.image--vdlQM');
        console.log(`Found ${avatarElements.length} elements with class "image--vdlQM"`);
        
        if (avatarElements.length >= 2) {
            // Use the second instance (index 1) as requested
            const avatarEl = avatarElements[1];
            if (avatarEl && avatarEl.src) {
                userImageURL = avatarEl.src;
                console.log(`Found avatar using second instance of .image--vdlQM selector`);
            }
        } else if (avatarElements.length === 1) {
            // Fallback to first if only one exists
            const avatarEl = avatarElements[0];
            if (avatarEl && avatarEl.src) {
                userImageURL = avatarEl.src;
                console.log(`Found avatar using first instance of .image--vdlQM selector`);
            }
        }
        
        // Look for username using the specific class you provided
        const nameSelectors = [
            '.h1--bZ6EI.L--opXRs', // Primary selector for user name
            '.h1--bZ6EI',          // Fallback without second class
            'h1.h1--bZ6EI',        // With h1 tag
            '.user-name',
            '.profile-name',
            'h1',
            'h2'
        ];
        
        for (const selector of nameSelectors) {
            const nameEl = document.querySelector(selector);
            if (nameEl && nameEl.textContent?.trim()) {
                displayName = nameEl.textContent.trim();
                console.log(`Found name using selector: ${selector} - "${displayName}"`);
                break;
            }
        }
        
        // Check if user is logged in by looking for logout button or user menu
        const loginIndicators = [
            '[data-testid="user-menu"]',
            '.user-menu',
            'button[aria-label*="logout"]',
            'a[href*="logout"]',
            '.dropdown-toggle[aria-label*="user"]'
        ];
        
        for (const selector of loginIndicators) {
            if (document.querySelector(selector)) {
                isLoggedIn = true;
                console.log(`User appears to be logged in (found: ${selector})`);
                break;
            }
        }
        
        // Extract user ID from URL or page elements
        if (urlMatch) {
            userId = urlMatch[1];
        }
        
        // If we found display name but no username from URL, use display name
        if (!username && displayName) {
            username = displayName;
        }
        
        // If we found username from URL but no display name, use username
        if (username && !displayName) {
            displayName = username;
        }
        
        console.log('Extracted user info:', {
            username: username,
            displayName: displayName,
            userImageURL: userImageURL,
            userId: userId,
            isLoggedIn: isLoggedIn
        });
        
        if (username || displayName) {
            return {
                username: username || displayName,
                displayName: displayName || username,
                userImageURL: userImageURL,
                userId: userId,
                isLoggedIn: isLoggedIn,
                profileUrl: window.location.href
            };
        }
        
        return { isLoggedIn: isLoggedIn };
    } catch (error) {
        console.error('Error extracting user info:', error);
        return null;
    }
}

async function handleSoundEffectsScan(request, tabId) {
    const { tabId: requestTabId } = request;
    const targetTabId = requestTabId || tabId;
    
    try {
        console.log('Starting sound effects scan...');
        
        // Send message to content script to start scanning
        try {
            await chrome.tabs.sendMessage(targetTabId, {
                action: 'SCAN_SOUND_EFFECTS'
            });
        } catch (error) {
            console.error('Error communicating with content script:', error);
            sendMessageToPopup({
                action: 'SCANNING_ERROR',
                error: 'Could not communicate with page. Try refreshing and try again.'
            });
        }
        
    } catch (error) {
        console.error('Sound effects scan error:', error);
        sendMessageToPopup({
            action: 'SCANNING_ERROR',
            error: error.message
        });
    }
}

function handleSoundEffectsExtracted(message, tabId) {
    const { items } = message;
    
    console.log(`Sound effects extracted: ${items.length} items`);
    
    // Store scanned items for later download
    scannedSoundEffects = items;
    
    // Forward to popup for display - DO NOT start download automatically
    sendMessageToPopup({
        action: 'SOUND_EFFECTS_SCANNED',
        items: items
    });
    
    if (items.length === 0) {
        sendMessageToPopup({
            action: 'SCANNING_ERROR',
            error: 'No sound effects found on this page'
        });
    }
}

// NEW: Handle explicit download start request
async function handleStartDownload(request, tabId) {
    const { tabId: requestTabId } = request;
    const targetTabId = requestTabId || tabId;
    
    if (scannedSoundEffects.length === 0) {
        sendMessageToPopup({
            action: 'DOWNLOAD_ERROR',
            error: 'No sound effects to download. Please scan first.'
        });
        return;
    }
    
    console.log(`Starting download of ${scannedSoundEffects.length} sound effects`);
    await startSoundEffectsDownload(scannedSoundEffects, targetTabId);
}

function handleScanningError(message) {
    console.error('Scanning error:', message.error);
    
    // Forward to popup
    sendMessageToPopup({
        action: 'SCANNING_ERROR',
        error: message.error
    });
}

async function startSoundEffectsDownload(soundEffects, tabId) {
    // Reset download control flags
    isDownloadPaused = false;
    isDownloadCanceled = false;
    currentDownloadSession = Date.now();
    downloadQueue = soundEffects;
    
    try {
        const totalCount = soundEffects.length;
        let downloadedCount = 0;
        
        console.log(`Starting download of ${totalCount} sound effects`);
        
        // Check if auto-like is enabled
        const autoLikeEnabled = await getAutoLikeSetting();
        
        // Notify that download is starting
        sendMessageToPopup({
            action: 'DOWNLOAD_STARTED',
            count: totalCount
        });
        
        // Create folder name for sound effects
        const folderName = 'pixabay_sound_effects';
        
        for (let i = 0; i < soundEffects.length; i++) {
            // Check for cancel/pause
            if (isDownloadCanceled) {
                console.log('Download canceled by user');
                break;
            }
            
            while (isDownloadPaused) {
                await sleep(500);
                if (isDownloadCanceled) break;
            }
            
            if (isDownloadCanceled) break;
            
            const soundEffect = soundEffects[i];
            
            try {
                // Auto-like if enabled
                if (autoLikeEnabled && soundEffect.element) {
                    await autoLikeSoundEffect(soundEffect, tabId);
                }
                
                await downloadSoundEffect(soundEffect, folderName, tabId);
                downloadedCount++;
                
                // Update progress
                sendMessageToPopup({
                    action: 'UPDATE_PROGRESS',
                    current: downloadedCount,
                    total: totalCount
                });
                
                // Add delay between downloads
                await sleep(500);
                
            } catch (error) {
                console.error(`Failed to download ${soundEffect.id}:`, error);
                // Continue with next file
            }
        }
        
        // Notify completion or cancellation
        if (isDownloadCanceled) {
            sendMessageToPopup({
                action: 'DOWNLOAD_CANCELED',
                count: downloadedCount
            });
        } else {
            sendMessageToPopup({
                action: 'DOWNLOAD_COMPLETE',
                count: downloadedCount
            });
        }
        
    } catch (error) {
        console.error('Download error:', error);
        sendMessageToPopup({
            action: 'DOWNLOAD_ERROR',
            error: error.message
        });
    }
}

async function autoLikeSoundEffect(soundEffect, tabId) {
    try {
        console.log(`Auto-liking sound effect: ${soundEffect.id}`);
        
        await chrome.scripting.executeScript({
            target: { tabId: tabId },
            function: clickLikeButton,
            args: [soundEffect.id]
        });
        
        // Small delay after liking
        await sleep(200);
        
    } catch (error) {
        console.log(`Could not auto-like sound effect ${soundEffect.id}: ${error.message}`);
    }
}

// Function to be injected to click the like button
function clickLikeButton(soundEffectId) {
    try {
        // Find like buttons with the specific classes
        const likeButtons = document.querySelectorAll('.button--9NFL8.square--n2VLb.light--C3NP-.center--ZZf40');
        
        console.log(`Found ${likeButtons.length} like buttons`);
        
        // Try to find the like button associated with this sound effect
        for (const button of likeButtons) {
            // Check if this button is near the sound effect element
            const soundEffectElement = document.querySelector(`[data-id="${soundEffectId}"]`) || 
                                     document.querySelector(`#sound-${soundEffectId}`) ||
                                     document.querySelector(`[href*="${soundEffectId}"]`);
            
            if (soundEffectElement) {
                // Check if the button is within the same container
                const container = soundEffectElement.closest('.overlayContainer--0ZpHP, .audioRow--nAm4Z, .media-item');
                if (container && container.contains(button)) {
                    console.log(`Clicking like button for sound effect ${soundEffectId}`);
                    button.click();
                    return true;
                }
            }
        }
        
        // If no specific association found, just click the first available like button
        if (likeButtons.length > 0) {
            console.log(`Clicking first available like button`);
            likeButtons[0].click();
            return true;
        }
        
        return false;
    } catch (error) {
        console.error(`Error clicking like button: ${error}`);
        return false;
    }
}

// Auto-like settings management
async function setAutoLikeSetting(enabled) {
    try {
        await chrome.storage.local.set({ 'autoLikeEnabled': enabled });
        console.log(`Auto-like setting updated: ${enabled}`);
    } catch (error) {
        console.error('Error saving auto-like setting:', error);
    }
}

async function getAutoLikeSetting() {
    try {
        const result = await chrome.storage.local.get(['autoLikeEnabled']);
        return result.autoLikeEnabled || false;
    } catch (error) {
        console.error('Error getting auto-like setting:', error);
        return false;
    }
}

async function downloadSoundEffect(soundEffect, folderName, tabId) {
    try {
        let downloadUrl = soundEffect.downloadUrl;
        
        console.log(`Processing sound effect ${soundEffect.id} with URL: ${downloadUrl}`);
        
        // Check if we have a direct audio file URL
        const isDirectAudioUrl = downloadUrl && (
            downloadUrl.includes('.mp3') || 
            downloadUrl.includes('.wav') || 
            downloadUrl.includes('.ogg') ||
            downloadUrl.includes('.aac') ||
            downloadUrl.includes('.m4a') ||
            downloadUrl.includes('.flac')
        );
        
        if (!isDirectAudioUrl) {
            console.log(`No direct audio URL found, attempting to extract from page: ${downloadUrl}`);
            
            // Try to extract audio URL from the page
            if (soundEffect.pageUrl || downloadUrl) {
                try {
                    const pageUrl = soundEffect.pageUrl || downloadUrl;
                    const extractedUrl = await extractAudioUrlFromPage(pageUrl);
                    if (extractedUrl) {
                        downloadUrl = extractedUrl;
                        console.log(`Successfully extracted audio URL: ${downloadUrl}`);
                    }
                } catch (error) {
                    console.log(`Failed to extract audio URL from page: ${error.message}`);
                }
            }
            
            // If still no direct audio URL, try preview URL as fallback
            if (!isDirectAudioUrl && soundEffect.previewUrl) {
                console.log(`Using preview URL as fallback: ${soundEffect.previewUrl}`);
                downloadUrl = soundEffect.previewUrl;
            }
        }
        
        // Validate that we have a downloadable URL
        if (!downloadUrl) {
            throw new Error(`No downloadable URL found for ${soundEffect.id}`);
        }
        
        // Create filename with proper extension detection
        const safeTitle = sanitizeFilename(soundEffect.title || `sound_effect_${soundEffect.id}`);
        let extension = getFileExtensionFromUrl(downloadUrl);
        
        // If extension detection fails, try to determine from content type
        if (!extension || extension === 'mp3') {
            try {
                const response = await fetch(downloadUrl, { method: 'HEAD' });
                const contentType = response.headers.get('content-type');
                if (contentType) {
                    if (contentType.includes('audio/mpeg')) extension = 'mp3';
                    else if (contentType.includes('audio/wav')) extension = 'wav';
                    else if (contentType.includes('audio/ogg')) extension = 'ogg';
                    else if (contentType.includes('audio/aac')) extension = 'aac';
                    else if (contentType.includes('audio/mp4')) extension = 'm4a';
                    else extension = 'mp3'; // Default fallback
                } else {
                    extension = 'mp3'; // Default fallback
                }
            } catch (error) {
                console.log(`Could not determine content type for ${downloadUrl}, using mp3`);
                extension = 'mp3';
            }
        }
        
        const filename = `${folderName}/${safeTitle}_${soundEffect.id}.${extension}`;
        
        console.log(`Downloading sound effect: ${filename} from ${downloadUrl}`);
        
        // Use Chrome's downloads API
        return new Promise((resolve, reject) => {
            chrome.downloads.download({
                url: downloadUrl,
                filename: filename,
                saveAs: false,
                conflictAction: 'uniquify'
            }, (downloadId) => {
                if (chrome.runtime.lastError) {
                    console.error(`Download failed for ${filename}:`, chrome.runtime.lastError);
                    reject(new Error(chrome.runtime.lastError.message));
                } else {
                    console.log(`Started download: ${downloadId} - ${filename}`);
                    resolve(downloadId);
                }
            });
        });
    } catch (error) {
        console.error(`Error downloading sound effect ${soundEffect.id}:`, error);
        throw error;
    }
}

// Function to extract audio URL from a Pixabay page
async function extractAudioUrlFromPage(pageUrl) {
    try {
        console.log(`Extracting audio URL from: ${pageUrl}`);
        
        const response = await fetch(pageUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const html = await response.text();
        
        // Enhanced patterns to find audio URLs in Pixabay pages
        const audioUrlPatterns = [
            // JSON data patterns
            /"preview":\s*"([^"]*\/[^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"audioURL":\s*"([^"]*\/[^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"downloadURL":\s*"([^"]*\/[^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            /"audio":\s*"([^"]*\/[^"]*\.(?:mp3|wav|ogg)[^"]*)"/gi,
            
            // Direct URL patterns
            /https:\/\/cdn\.pixabay\.com\/audio\/[^"'\s]*\.(?:mp3|wav|ogg)/gi,
            /https:\/\/pixabay\.com\/[^"'\s]*\.(?:mp3|wav|ogg)/gi,
            /https:\/\/[^"'\s]*pixabay[^"'\s]*\.(?:mp3|wav|ogg)/gi,
            
            // HTML attribute patterns
            /data-audio[-_]?url=["']([^"']*\.(?:mp3|wav|ogg)[^"']*)["']/gi,
            /src=["']([^"']*\.(?:mp3|wav|ogg)[^"']*)["']/gi,
            
            // General audio file patterns
            /https:\/\/[^"'\s]*\.mp3/gi,
            /https:\/\/[^"'\s]*\.wav/gi,
            /https:\/\/[^"'\s]*\.ogg/gi
        ];
        
        for (const pattern of audioUrlPatterns) {
            pattern.lastIndex = 0; // Reset regex state
            const matches = [...html.matchAll(pattern)];
            
            if (matches.length > 0) {
                for (const match of matches) {
                    let audioUrl = match[1] || match[0];
                    
                    // Clean up the URL
                    audioUrl = audioUrl.replace(/\\"/g, '"').replace(/\\/g, '');
                    
                    // Ensure proper protocol
                    if (audioUrl.startsWith('//')) {
                        audioUrl = 'https:' + audioUrl;
                    } else if (audioUrl.startsWith('/')) {
                        audioUrl = 'https://pixabay.com' + audioUrl;
                    }
                    
                    // Validate the URL looks like an audio file
                    if (audioUrl.match(/\.(?:mp3|wav|ogg|aac|m4a|flac)(?:\?|$)/i)) {
                        console.log(`Found potential audio URL: ${audioUrl}`);
                        return audioUrl;
                    }
                }
            }
        }
        
        throw new Error('No audio URL found in page content');
        
    } catch (error) {
        console.error(`Failed to extract audio URL from ${pageUrl}:`, error);
        throw error;
    }
}

function getFileExtensionFromUrl(url) {
    if (!url) return 'mp3';
    
    try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        const extension = pathname.split('.').pop()?.toLowerCase();
        
        if (extension && ['mp3', 'wav', 'ogg', 'aac', 'm4a', 'flac'].includes(extension)) {
            return extension;
        }
        
        return 'mp3'; // Default for audio files
    } catch {
        return 'mp3';
    }
}

function pauseDownload() {
    isDownloadPaused = true;
    console.log('Download paused');
    sendMessageToPopup({ action: 'DOWNLOAD_PAUSED' });
}

function resumeDownload() {
    isDownloadPaused = false;
    console.log('Download resumed');
    sendMessageToPopup({ action: 'DOWNLOAD_RESUMED' });
}

function cancelDownload() {
    isDownloadCanceled = true;
    isDownloadPaused = false;
    downloadQueue = [];
    console.log('Download canceled');
    sendMessageToPopup({ action: 'DOWNLOAD_CANCELED' });
}

function sanitizeFilename(filename) {
    if (!filename) return 'unknown';
    return filename
        .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_')
        .replace(/\s+/g, '_')
        .replace(/_{2,}/g, '_')
        .toLowerCase()
        .substring(0, 50);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Helper function to send messages to popup safely
async function sendMessageToPopup(message) {
    try {
        await chrome.runtime.sendMessage(message);
    } catch (error) {
        // Popup might be closed, which is normal - just log it
        console.log('Could not send message to popup (popup may be closed):', message.action);
    }
}

// Handle extension installation
chrome.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
        console.log('Pixabay Sound Effects Downloader installed');
        chrome.storage.local.set({
            'firstInstall': true,
            'installDate': new Date().toISOString(),
            'scrapingMode': 'sound-effects',
            'autoLikeEnabled': false,
            'version': '3.1'
        });
    }
});