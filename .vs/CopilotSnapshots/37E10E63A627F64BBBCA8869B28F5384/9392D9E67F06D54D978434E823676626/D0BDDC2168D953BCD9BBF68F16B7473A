// Background service worker for Pixabay Mass Downloader - Web Scraping Version
console.log('Pixabay Mass Downloader (Web Scraper) background script loaded');

// Download control variables
let isDownloadPaused = false;
let isDownloadCanceled = false;
let currentDownloadSession = null;
let downloadQueue = [];

// Listen for messages from popup and content scripts
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    switch (message.action) {
        case 'START_SCRAPE_DOWNLOAD':
            handleScrapeDownloadRequest(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
        case 'PAUSE_DOWNLOAD':
            pauseDownload();
            sendResponse({ success: true });
            break;
        case 'RESUME_DOWNLOAD':
            resumeDownload();
            sendResponse({ success: true });
            break;
        case 'CANCEL_DOWNLOAD':
            cancelDownload();
            sendResponse({ success: true });
            break;
        case 'GET_USER_INFO':
            getUserInfoFromPage(message.tabId);
            sendResponse({ success: true });
            break;
        case 'SCRAPE_CATEGORY':
            scrapeCategoryContent(message, sender.tab?.id || null);
            sendResponse({ success: true });
            break;
    }
    return true;
});

async function getUserInfoFromPage(tabId) {
    try {
        // Inject script to extract user info from the current page
        const results = await chrome.scripting.executeScript({
            target: { tabId: tabId },
            function: extractUserInfoFromPage
        });
        
        if (results && results[0] && results[0].result) {
            const userInfo = results[0].result;
            
            // Send user info to popup
            chrome.runtime.sendMessage({
                action: 'USER_INFO_RECEIVED',
                userInfo: userInfo
            }).catch(() => {});
        }
    } catch (error) {
        console.error('Error getting user info from page:', error);
    }
}

// Function to be injected into the page to extract user info
function extractUserInfoFromPage() {
    try {
        // Extract username from URL
        const urlMatch = window.location.pathname.match(/\/users\/([^\/\?]+)/);
        const username = urlMatch ? decodeURIComponent(urlMatch[1]) : null;
        
        if (!username) return null;
        
        // Try to find user avatar and info on the page
        let userImageURL = '';
        let userId = '';
        
        // Look for user avatar in various possible locations
        const avatarSelectors = [
            '.user-avatar img',
            '.profile-avatar img',
            '.user-profile img',
            '[data-testid="user-avatar"] img',
            '.avatar img'
        ];
        
        for (const selector of avatarSelectors) {
            const avatarEl = document.querySelector(selector);
            if (avatarEl && avatarEl.src) {
                userImageURL = avatarEl.src;
                break;
            }
        }
        
        return {
            username: username,
            userImageURL: userImageURL,
            userId: userId,
            profileUrl: window.location.href
        };
    } catch (error) {
        console.error('Error extracting user info:', error);
        return null;
    }
}

async function scrapeCategoryContent(request, tabId) {
    const { category, username } = request;
    
    try {
        console.log(`Starting to scrape ${category} content for user: ${username}`);
        
        // Inject content script to scrape the specific category
        const results = await chrome.scripting.executeScript({
            target: { tabId: tabId },
            function: scrapeContentByCategory,
            args: [category, username]
        });
        
        if (results && results[0] && results[0].result) {
            const contentItems = results[0].result;
            console.log(`Found ${contentItems.length} ${category} items for ${username}`);
            
            if (contentItems.length > 0) {
                await startDownloadQueue(contentItems, category, username, tabId);
            } else {
                notifyError(tabId, `No ${category} content found for ${username}`);
            }
        }
    } catch (error) {
        console.error(`Error scraping ${category} content:`, error);
        notifyError(tabId, `Failed to scrape ${category} content: ${error.message}`);
    }
}

// Function to be injected to scrape content by category
function scrapeContentByCategory(category, username) {
    console.log(`Scraping ${category} content...`);
    
    // Map category to Pixabay URLs and selectors
    const categoryConfig = {
        photos: {
            path: '/photos/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: 'img[alt], .title, h3',
                image: 'img'
            }
        },
        illustrations: {
            path: '/illustrations/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: 'img[alt], .title, h3',
                image: 'img'
            }
        },
        vectors: {
            path: '/vectors/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: 'img[alt], .title, h3',
                image: 'img'
            }
        },
        videos: {
            path: '/videos/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: 'img[alt], .title, h3, .video-title',
                image: 'img, video'
            }
        },
        music: {
            path: '/music/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item, .audio-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: '.title, h3, .audio-title, .track-title',
                image: 'img'
            }
        },
        'sound-effects': {
            path: '/sound-effects/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item, .audio-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: '.title, h3, .audio-title, .track-title',
                image: 'img'
            }
        },
        gifs: {
            path: '/gifs/',
            selectors: {
                items: 'div[data-testid="media-item"], .item, .media-item',
                downloadBtn: 'a[href*="/download/"], button[aria-label*="download"], .download-btn',
                title: 'img[alt], .title, h3',
                image: 'img'
            }
        }
    };
    
    const config = categoryConfig[category];
    if (!config) {
        console.error(`Unknown category: ${category}`);
        return [];
    }
    
    // Navigate to category page if not already there
    const expectedPath = `/users/${username}${config.path}`;
    if (!window.location.pathname.includes(expectedPath)) {
        console.log(`Navigating to ${expectedPath}`);
        // We'll need to handle navigation differently - return instruction to navigate
        return { needsNavigation: true, url: `https://pixabay.com/users/${username}${config.path}` };
    }
    
    // Scrape content items from current page
    const contentItems = [];
    const itemElements = document.querySelectorAll(config.selectors.items);
    
    console.log(`Found ${itemElements.length} potential items`);
    
    itemElements.forEach((item, index) => {
        try {
            // Extract download link
            const downloadBtn = item.querySelector(config.selectors.downloadBtn);
            let downloadUrl = '';
            
            if (downloadBtn) {
                if (downloadBtn.tagName === 'A') {
                    downloadUrl = downloadBtn.href;
                } else {
                    // For buttons, we might need to click them or extract data attributes
                    downloadUrl = downloadBtn.getAttribute('data-download-url') || 
                                 downloadBtn.getAttribute('data-href') || '';
                }
            }
            
            // Extract title/name
            const titleEl = item.querySelector(config.selectors.title);
            const title = titleEl ? (titleEl.alt || titleEl.textContent || titleEl.innerText || '').trim() : `${category}_${index}`;
            
            // Extract preview image
            const imageEl = item.querySelector(config.selectors.image);
            const previewUrl = imageEl ? imageEl.src : '';
            
            // Extract item ID from various possible sources
            let itemId = '';
            const idMatch = item.id.match(/\d+/) || 
                           (downloadUrl.match(/\/(\d+)\//) || [])[1] ||
                           (previewUrl.match(/\/(\d+)_/) || [])[1] ||
                           `item_${index}`;
            
            if (typeof idMatch === 'string') {
                itemId = idMatch;
            } else if (Array.isArray(idMatch)) {
                itemId = idMatch[0] || `item_${index}`;
            } else {
                itemId = `item_${index}`;
            }
            
            if (downloadUrl || previewUrl) {
                contentItems.push({
                    id: itemId,
                    title: title,
                    downloadUrl: downloadUrl,
                    previewUrl: previewUrl,
                    category: category,
                    element: item,
                    index: index
                });
            }
        } catch (error) {
            console.error(`Error processing item ${index}:`, error);
        }
    });
    
    console.log(`Successfully extracted ${contentItems.length} items`);
    return contentItems;
}

async function handleScrapeDownloadRequest(request, tabId) {
    const { category, username } = request;
    
    // Reset download control flags
    isDownloadPaused = false;
    isDownloadCanceled = false;
    currentDownloadSession = Date.now();
    downloadQueue = [];
    
    try {
        console.log(`Starting scrape download for ${category} from user: ${username}`);
        
        // Notify that download is starting
        notifyDownloadStarted(tabId, username, category);
        
        // Start scraping the specific category
        await scrapeCategoryContent({ category, username }, tabId);
        
    } catch (error) {
        console.error('Scrape download error:', error);
        notifyError(tabId, error.message);
    }
}

async function startDownloadQueue(contentItems, category, username, tabId) {
    try {
        downloadQueue = contentItems;
        const totalCount = contentItems.length;
        let downloadedCount = 0;
        
        // Create folder name
        const folderName = `${sanitizeFilename(username)}_${category}`;
        
        console.log(`Starting download of ${totalCount} ${category} items to folder: ${folderName}`);
        
        for (let i = 0; i < contentItems.length; i++) {
            // Check for cancel/pause
            if (isDownloadCanceled) {
                console.log('Download canceled by user');
                break;
            }
            
            while (isDownloadPaused) {
                await sleep(500);
                if (isDownloadCanceled) break;
            }
            
            if (isDownloadCanceled) break;
            
            const item = contentItems[i];
            
            try {
                await downloadContentItem(item, folderName, username, tabId);
                downloadedCount++;
                
                // Update progress
                notifyProgress(tabId, downloadedCount, totalCount);
                
                // Add delay between downloads
                await sleep(500);
                
            } catch (error) {
                console.error(`Failed to download ${item.id}:`, error);
                // Continue with next file
            }
        }
        
        // Notify completion or cancellation
        if (isDownloadCanceled) {
            notifyDownloadCanceled(tabId, downloadedCount);
        } else {
            notifyComplete(tabId, downloadedCount);
        }
        
    } catch (error) {
        console.error('Download queue error:', error);
        notifyError(tabId, error.message);
    }
}

async function downloadContentItem(item, folderName, username, tabId) {
    try {
        let downloadUrl = item.downloadUrl;
        
        // If no direct download URL, try to get the actual download link
        if (!downloadUrl && item.previewUrl) {
            // Use preview URL as fallback
            downloadUrl = item.previewUrl;
        }
        
        if (!downloadUrl) {
            throw new Error(`No download URL found for item ${item.id}`);
        }
        
        // Determine file extension
        const extension = getFileExtension(downloadUrl, item.category);
        
        // Create filename
        const safeTitle = sanitizeFilename(item.title || `${item.category}_${item.id}`);
        const filename = `${folderName}/${username}_${item.id}_${safeTitle}.${extension}`;
        
        console.log(`Downloading: ${filename} from ${downloadUrl}`);
        
        // Use Chrome's downloads API
        return new Promise((resolve, reject) => {
            chrome.downloads.download({
                url: downloadUrl,
                filename: filename,
                saveAs: false,
                conflictAction: 'uniquify'
            }, (downloadId) => {
                if (chrome.runtime.lastError) {
                    console.error(`Download failed for ${filename}:`, chrome.runtime.lastError);
                    reject(new Error(chrome.runtime.lastError.message));
                } else {
                    console.log(`Started download: ${downloadId} - ${filename}`);
                    resolve(downloadId);
                }
            });
        });
    } catch (error) {
        console.error(`Error downloading item ${item.id}:`, error);
        throw error;
    }
}

function getFileExtension(url, category) {
    try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        const extension = pathname.split('.').pop()?.toLowerCase();
        
        if (extension && ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'mp4', 'webm', 'mp3', 'wav', 'ogg'].includes(extension)) {
            return extension;
        }
        
        // Default extensions by category
        const defaultExtensions = {
            photos: 'jpg',
            illustrations: 'jpg',
            vectors: 'svg',
            videos: 'mp4',
            music: 'mp3',
            'sound-effects': 'mp3',
            gifs: 'gif'
        };
        
        return defaultExtensions[category] || 'jpg';
    } catch {
        return 'jpg';
    }
}

function pauseDownload() {
    isDownloadPaused = true;
    console.log('Download paused');
    notifyDownloadPaused();
}

function resumeDownload() {
    isDownloadPaused = false;
    console.log('Download resumed');
    notifyDownloadResumed();
}

function cancelDownload() {
    isDownloadCanceled = true;
    isDownloadPaused = false;
    downloadQueue = [];
    console.log('Download canceled');
    notifyDownloadCanceled();
}

function sanitizeFilename(filename) {
    if (!filename) return 'unknown';
    return filename
        .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_')
        .replace(/\s+/g, '_')
        .replace(/_{2,}/g, '_')
        .toLowerCase()
        .substring(0, 50);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Notification functions
function notifyDownloadStarted(tabId, username, category) {
    const message = { action: 'DOWNLOAD_STARTED', username, category };
    if (tabId) chrome.tabs.sendMessage(tabId, message).catch(() => {});
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyProgress(tabId, current, total) {
    const message = { action: 'UPDATE_PROGRESS', current, total };
    if (tabId) chrome.tabs.sendMessage(tabId, message).catch(() => {});
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyComplete(tabId, count) {
    const message = { action: 'DOWNLOAD_COMPLETE', count };
    if (tabId) chrome.tabs.sendMessage(tabId, message).catch(() => {});
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyDownloadPaused() {
    const message = { action: 'DOWNLOAD_PAUSED' };
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyDownloadResumed() {
    const message = { action: 'DOWNLOAD_RESUMED' };
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyDownloadCanceled(tabId, count) {
    const message = { action: 'DOWNLOAD_CANCELED', count: count || 0 };
    if (tabId) chrome.tabs.sendMessage(tabId, message).catch(() => {});
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyError(tabId, error) {
    const message = { action: 'DOWNLOAD_ERROR', error };
    if (tabId) chrome.tabs.sendMessage(tabId, message).catch(() => {});
    chrome.runtime.sendMessage(message).catch(() => {});
}

// Handle extension installation
chrome.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
        console.log('Pixabay Mass Downloader (Web Scraper) installed');
        chrome.storage.local.set({
            'firstInstall': true,
            'installDate': new Date().toISOString(),
            'scrapingMode': true
        });
    }
});