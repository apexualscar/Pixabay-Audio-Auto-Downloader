// JavaScript functions for file downloading and Chrome extension integration

window.downloadFile = (url, filename) => {
    return new Promise((resolve, reject) => {
        try {
            // Create a temporary anchor element
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            
            // Add to DOM, click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            resolve();
        } catch (error) {
            reject(error);
        }
    });
};

// Enhanced download function that supports folder structure
window.downloadFileToFolder = (url, filepath) => {
    return new Promise((resolve, reject) => {
        try {
            // Extract filename from filepath for display
            const filename = filepath.split('/').pop() || 'download';
            
            // Create a temporary anchor element
            const link = document.createElement('a');
            link.href = url;
            link.download = filepath; // Use full path including folder
            link.style.display = 'none';
            
            // Add to DOM, click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            resolve();
        } catch (error) {
            reject(error);
        }
    });
};

window.downloadBlob = (data, filename, mimeType) => {
    const blob = new Blob([data], { type: mimeType });
    const url = window.URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL object
    window.URL.revokeObjectURL(url);
};

window.downloadFromUrl = async (url, filename) => {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const blob = await response.blob();
        const objectUrl = window.URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = objectUrl;
        link.download = filename;
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up
        window.URL.revokeObjectURL(objectUrl);
        
        return true;
    } catch (error) {
        console.error('Download failed:', error);
        throw error;
    }
};

// Batch download function with folder support
window.downloadBatch = async (downloads, progressCallback) => {
    let completed = 0;
    const total = downloads.length;
    
    for (const download of downloads) {
        try {
            await window.downloadFileToFolder(download.url, download.filepath);
            completed++;
            
            if (progressCallback) {
                progressCallback(completed, total);
            }
            
            // Add small delay between downloads
            await window.utils.sleep(150);
            
        } catch (error) {
            console.error(`Failed to download ${download.filepath}:`, error);
            // Continue with next download
        }
    }
    
    return completed;
};

// Chrome extension specific functions
window.chromeExtension = {
    isAvailable: () => {
        return typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id;
    },
    
    sendMessage: (message) => {
        if (window.chromeExtension.isAvailable()) {
            return new Promise((resolve, reject) => {
                chrome.runtime.sendMessage(message, (response) => {
                    if (chrome.runtime.lastError) {
                        reject(new Error(chrome.runtime.lastError.message));
                    } else {
                        resolve(response);
                    }
                });
            });
        } else {
            return Promise.reject(new Error('Chrome extension not available'));
        }
    },
    
    getCurrentTab: () => {
        if (window.chromeExtension.isAvailable()) {
            return new Promise((resolve) => {
                chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
                    resolve(tabs[0]);
                });
            });
        } else {
            return Promise.resolve(null);
        }
    },
    
    // Download using Chrome's native download API (if available)
    downloadNative: (url, filename) => {
        if (window.chromeExtension.isAvailable() && chrome.downloads) {
            return new Promise((resolve, reject) => {
                chrome.downloads.download({
                    url: url,
                    filename: filename,
                    saveAs: false,
                    conflictAction: 'uniquify'
                }, (downloadId) => {
                    if (chrome.runtime.lastError) {
                        reject(new Error(chrome.runtime.lastError.message));
                    } else {
                        resolve(downloadId);
                    }
                });
            });
        } else {
            // Fallback to regular download
            return window.downloadFileToFolder(url, filename);
        }
    }
};

// Storage helpers for the web app (fallback when not in extension context)
window.secureStorage = {
    getItem: (key) => {
        try {
            if (window.chromeExtension.isAvailable()) {
                return new Promise((resolve) => {
                    chrome.storage.local.get([key], (result) => {
                        resolve(result[key] || null);
                    });
                });
            } else {
                return Promise.resolve(localStorage.getItem(key));
            }
        } catch (error) {
            console.error('Error reading from storage:', error);
            return Promise.resolve(null);
        }
    },
    
    setItem: (key, value) => {
        try {
            if (window.chromeExtension.isAvailable()) {
                return new Promise((resolve) => {
                    chrome.storage.local.set({ [key]: value }, () => {
                        resolve(true);
                    });
                });
            } else {
                localStorage.setItem(key, value);
                return Promise.resolve(true);
            }
        } catch (error) {
            console.error('Error writing to storage:', error);
            return Promise.resolve(false);
        }
    },
    
    removeItem: (key) => {
        try {
            if (window.chromeExtension.isAvailable()) {
                return new Promise((resolve) => {
                    chrome.storage.local.remove([key], () => {
                        resolve(true);
                    });
                });
            } else {
                localStorage.removeItem(key);
                return Promise.resolve(true);
            }
        } catch (error) {
            console.error('Error removing from storage:', error);
            return Promise.resolve(false);
        }
    }
};

// Progress tracking for downloads
window.downloadProgress = {
    current: 0,
    total: 0,
    callbacks: [],
    
    update: (current, total) => {
        window.downloadProgress.current = current;
        window.downloadProgress.total = total;
        
        // Notify all callbacks
        window.downloadProgress.callbacks.forEach(callback => {
            try {
                callback(current, total);
            } catch (error) {
                console.error('Error in progress callback:', error);
            }
        });
    },
    
    addCallback: (callback) => {
        window.downloadProgress.callbacks.push(callback);
    },
    
    removeCallback: (callback) => {
        const index = window.downloadProgress.callbacks.indexOf(callback);
        if (index > -1) {
            window.downloadProgress.callbacks.splice(index, 1);
        }
    },
    
    reset: () => {
        window.downloadProgress.current = 0;
        window.downloadProgress.total = 0;
    }
};

// Utility functions
window.utils = {
    sleep: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
    
    generateFilename: (originalUrl, prefix = '', extension = '') => {
        const url = new URL(originalUrl);
        const pathname = url.pathname;
        const filename = pathname.split('/').pop() || 'download';
        const name = filename.split('.')[0];
        const ext = extension || filename.split('.').pop() || '';
        
        return `${prefix}${name}.${ext}`;
    },
    
    sanitizeFilename: (filename) => {
        if (!filename) return 'unknown';
        return filename
            .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_')
            .replace(/\s+/g, '_')
            .replace(/_{2,}/g, '_')
            .toLowerCase()
            .substring(0, 50);
    },
    
    validateApiKey: (apiKey) => {
        return apiKey && typeof apiKey === 'string' && apiKey.length > 10;
    },
    
    extractUsernameFromUrl: (url) => {
        const match = url.match(/\/users\/([^\/\?]+)/);
        return match ? decodeURIComponent(match[1]) : null;
    },
    
    // Create folder structure in filename
    createFolderPath: (username, contentType, filename) => {
        const sanitizedUser = window.utils.sanitizeFilename(username);
        const folderName = `${sanitizedUser}_${contentType}`;
        return `${folderName}/${filename}`;
    },
    
    // Show notification (if supported)
    showNotification: (title, message, type = 'info') => {
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification(title, {
                body: message,
                icon: '/favicon.png'
            });
        } else {
            console.log(`${title}: ${message}`);
        }
    }
};