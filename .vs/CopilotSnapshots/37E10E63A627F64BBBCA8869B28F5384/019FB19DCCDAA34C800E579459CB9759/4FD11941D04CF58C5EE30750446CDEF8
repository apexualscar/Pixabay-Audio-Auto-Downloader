// Background service worker for the Chrome extension
console.log('Pixabay Mass Downloader background script loaded');

// Rate limiting variables
const API_RATE_LIMIT = 60; // requests per second
const RATE_LIMIT_WINDOW = 1000; // 1 second in milliseconds
let requestQueue = [];
let isProcessingQueue = false;

// Listen for messages from popup and content scripts
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'START_DOWNLOAD') {
        handleDownloadRequest(message, sender.tab?.id || null);
        sendResponse({ success: true });
    }
    return true; // Keep message channel open for async response
});

async function handleDownloadRequest(request, tabId) {
    const { username, contentType, apiKey } = request;
    
    try {
        console.log(`Starting download for user: ${username}, type: ${contentType}`);
        
        // Notify that download is starting
        notifyDownloadStarted(tabId, username, contentType);
        
        // Get user's submissions from Pixabay API with rate limiting
        const submissions = await fetchUserSubmissionsWithRateLimit(username, contentType, apiKey);
        
        if (submissions.length === 0) {
            const errorMsg = 'No submissions found for this user and content type';
            notifyError(tabId, errorMsg);
            return;
        }
        
        console.log(`Found ${submissions.length} submissions to download`);
        
        // Download each submission with proper folder structure
        let downloadedCount = 0;
        const totalCount = submissions.length;
        
        // Create folder name: username_contenttype (e.g., "john_doe_images")
        const folderName = `${sanitizeFilename(username)}_${contentType}`;
        
        for (let i = 0; i < submissions.length; i++) {
            const submission = submissions[i];
            
            try {
                await downloadFileToFolder(submission, contentType, folderName, username);
                downloadedCount++;
                
                // Update progress
                notifyProgress(tabId, downloadedCount, totalCount);
                
                // Add delay to avoid overwhelming the download system
                await sleep(100);
                
            } catch (error) {
                console.error(`Failed to download ${submission.id}:`, error);
                // Continue with next file even if one fails
            }
        }
        
        // Notify completion
        notifyComplete(tabId, downloadedCount);
        
    } catch (error) {
        console.error('Download error:', error);
        notifyError(tabId, error.message);
    }
}

async function fetchUserSubmissionsWithRateLimit(username, contentType, apiKey) {
    const baseUrl = 'https://pixabay.com/api/';
    const submissions = [];
    let page = 1;
    const perPage = 200; // Maximum allowed by Pixabay API
    
    try {
        while (true) {
            // Construct API URL with proper parameters
            const params = new URLSearchParams({
                key: apiKey,
                username: username,
                per_page: perPage,
                page: page,
                safesearch: 'true',
                order: 'latest'
            });
            
            // Handle different content types
            if (contentType === 'photo') {
                params.set('category', 'all');
                params.set('image_type', 'all');
            } else if (contentType === 'music') {
                // For music/audio, we need to use different endpoint or parameters
                // Pixabay's main API is primarily for images, videos have limited support
                params.set('category', 'music');
            } else if (contentType === 'video') {
                // For videos, there might be different API limitations
                params.set('category', 'all');
                params.set('video', 'true');
            } else {
                // For 'all' content, just get images by default
                params.set('category', 'all');
            }
            
            const url = `${baseUrl}?${params.toString()}`;
            
            console.log(`Fetching page ${page} for ${username} (${contentType})...`);
            
            // Use rate-limited request
            const response = await makeRateLimitedRequest(url);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`API request failed for page ${page}:`, response.status, errorText);
                
                // If it's a page out of range error, we've reached the end
                if (response.status === 400 && errorText.includes('page')) {
                    console.log(`Reached end of results at page ${page}`);
                    break;
                }
                
                throw new Error(`API request failed: ${response.status} - ${errorText}`);
            }
            
            const data = await response.json();
            
            // Check if we have any results
            if (!data.hits || data.hits.length === 0) {
                console.log(`No more results found at page ${page}`);
                break; // No more results
            }
            
            console.log(`Page ${page}: Found ${data.hits.length} submissions (total so far: ${submissions.length + data.hits.length})`);
            
            submissions.push(...data.hits);
            
            // If we got less than perPage results, we've reached the end
            if (data.hits.length < perPage) {
                console.log(`Got fewer results than requested (${data.hits.length} < ${perPage}), reached end`);
                break;
            }
            
            // Check if we've reached the maximum pages (Pixabay typically limits to ~50 pages)
            if (page >= 50) {
                console.log(`Reached maximum page limit (${page}), stopping`);
                break;
            }
            
            // If total hits is available, check if we've got all possible results
            if (data.total && submissions.length >= data.total) {
                console.log(`Got all available results (${submissions.length}/${data.total})`);
                break;
            }
            
            page++;
            
            // Respect API rate limits - add delay between requests
            await sleep(1000); // 1 second delay between pages
        }
        
        console.log(`Finished fetching: found ${submissions.length} total submissions for ${username}`);
        return submissions;
        
    } catch (error) {
        console.error('Error fetching submissions:', error);
        throw error;
    }
}

async function makeRateLimitedRequest(url) {
    return new Promise((resolve, reject) => {
        const requestTime = Date.now();
        
        // Add request to queue
        requestQueue.push({
            url,
            timestamp: requestTime,
            resolve,
            reject
        });
        
        // Process queue if not already processing
        if (!isProcessingQueue) {
            processRequestQueue();
        }
    });
}

async function processRequestQueue() {
    isProcessingQueue = true;
    
    while (requestQueue.length > 0) {
        const now = Date.now();
        
        // Remove requests older than rate limit window
        requestQueue = requestQueue.filter(req => now - req.timestamp < RATE_LIMIT_WINDOW * 10);
        
        // Check if we can make a request (stay under rate limit)
        const recentRequests = requestQueue.filter(req => now - req.timestamp < RATE_LIMIT_WINDOW);
        
        if (recentRequests.length >= API_RATE_LIMIT) {
            // Wait before processing more requests
            await sleep(100);
            continue;
        }
        
        // Get next request
        const request = requestQueue.shift();
        if (!request) continue;
        
        try {
            console.log(`Making API request: ${request.url}`);
            const response = await fetch(request.url);
            request.resolve(response);
        } catch (error) {
            console.error(`Request failed: ${error.message}`);
            request.reject(error);
        }
        
        // Small delay between requests
        await sleep(50); // Increased delay to be more conservative
    }
    
    isProcessingQueue = false;
}

async function downloadFileToFolder(submission, contentType, folderName, username) {
    // Determine the best download URL and filename based on content type
    const { downloadUrl, filename, extension } = getDownloadInfo(submission, contentType);
    
    if (!downloadUrl) {
        throw new Error('No download URL available for this submission');
    }
    
    // Create full filename with proper extension
    const safeUser = sanitizeFilename(submission.user || username);
    const safeTag = sanitizeFilename(getFirstTag(submission.tags) || 'content');
    const fullFilename = `${folderName}/${safeUser}_${submission.id}_${safeTag}.${extension}`;
    
    console.log(`Downloading: ${fullFilename} from ${downloadUrl}`);
    
    // Use Chrome's downloads API with folder structure
    return new Promise((resolve, reject) => {
        chrome.downloads.download({
            url: downloadUrl,
            filename: fullFilename,
            saveAs: false,
            conflictAction: 'uniquify' // Add number if file exists
        }, (downloadId) => {
            if (chrome.runtime.lastError) {
                console.error(`Download failed for ${fullFilename}:`, chrome.runtime.lastError);
                reject(new Error(chrome.runtime.lastError.message));
            } else {
                console.log(`Started download: ${downloadId} - ${fullFilename}`);
                resolve(downloadId);
            }
        });
    });
}

function getDownloadInfo(submission, contentType) {
    switch (contentType.toLowerCase()) {
        case 'photo':
            return {
                downloadUrl: submission.largeImageURL || submission.fullHDURL || submission.webformatURL,
                filename: `image_${submission.id}`,
                extension: getExtensionFromUrl(submission.largeImageURL || submission.webformatURL) || 'jpg'
            };
            
        case 'music':
            // For music, we'll download the preview or use webformat as fallback
            return {
                downloadUrl: submission.previewURL || submission.webformatURL,
                filename: `audio_${submission.id}`,
                extension: 'mp3'
            };
            
        case 'video':
            const videoUrl = submission.videos?.large?.url || 
                           submission.videos?.medium?.url || 
                           submission.videos?.small?.url ||
                           submission.videos?.tiny?.url;
            return {
                downloadUrl: videoUrl,
                filename: `video_${submission.id}`,
                extension: 'mp4'
            };
            
        default:
            return {
                downloadUrl: submission.largeImageURL || submission.webformatURL,
                filename: `content_${submission.id}`,
                extension: getExtensionFromUrl(submission.webformatURL) || 'jpg'
            };
    }
}

function getExtensionFromUrl(url) {
    if (!url) return 'jpg';
    try {
        const pathname = new URL(url).pathname;
        const extension = pathname.split('.').pop()?.toLowerCase();
        return extension || 'jpg';
    } catch {
        return 'jpg';
    }
}

function getFirstTag(tags) {
    if (!tags) return 'content';
    const firstTag = tags.split(',')[0]?.trim();
    return firstTag || 'content';
}

function sanitizeFilename(filename) {
    if (!filename) return 'unknown';
    // Remove or replace characters that are not allowed in filenames
    return filename
        .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_') // Replace invalid chars with underscore
        .replace(/\s+/g, '_') // Replace spaces with underscore
        .replace(/_{2,}/g, '_') // Replace multiple underscores with single
        .toLowerCase()
        .substring(0, 50); // Limit length
}

function notifyDownloadStarted(tabId, username, contentType) {
    const message = {
        action: 'DOWNLOAD_STARTED',
        username: username,
        contentType: contentType
    };
    
    // Notify tab content script
    if (tabId) {
        chrome.tabs.sendMessage(tabId, message).catch(() => {});
    }
    
    // Notify popup
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyProgress(tabId, current, total) {
    const message = {
        action: 'UPDATE_PROGRESS',
        current: current,
        total: total
    };
    
    // Notify tab content script
    if (tabId) {
        chrome.tabs.sendMessage(tabId, message).catch(() => {});
    }
    
    // Notify popup
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyComplete(tabId, count) {
    const message = {
        action: 'DOWNLOAD_COMPLETE',
        count: count
    };
    
    // Notify tab content script
    if (tabId) {
        chrome.tabs.sendMessage(tabId, message).catch(() => {});
    }
    
    // Notify popup
    chrome.runtime.sendMessage(message).catch(() => {});
}

function notifyError(tabId, error) {
    const message = {
        action: 'DOWNLOAD_ERROR',
        error: error
    };
    
    // Notify tab content script
    if (tabId) {
        chrome.tabs.sendMessage(tabId, message).catch(() => {});
    }
    
    // Notify popup
    chrome.runtime.sendMessage(message).catch(() => {});
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Handle extension installation
chrome.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
        console.log('Pixabay Mass Downloader installed');
        
        // Set default storage
        chrome.storage.local.set({
            'firstInstall': true,
            'installDate': new Date().toISOString()
        });
    }
});

// Clean up request queue periodically
setInterval(() => {
    const now = Date.now();
    const oldLength = requestQueue.length;
    requestQueue = requestQueue.filter(req => now - req.timestamp < RATE_LIMIT_WINDOW * 60); // Keep for 60 seconds
    
    if (requestQueue.length !== oldLength) {
        console.log(`Cleaned up request queue: ${oldLength} -> ${requestQueue.length}`);
    }
}, 30000); // Clean every 30 seconds